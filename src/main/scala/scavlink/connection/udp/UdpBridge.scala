package scavlink.connection.udp

import java.net.InetSocketAddress

import akka.actor.{Actor, ActorLogging, ActorRef, Props}
import akka.io.{IO, Udp}
import scavlink.ScavlinkInitializer
import scavlink.connection._
import scavlink.connection.frame.{FrameReceiver, FrameSender}
import scavlink.connection.marshal.{MarshallerFactory, MessageMarshaller}
import scavlink.link.{Vehicle, Link, SubscribeTo}
import scavlink.message._
import scavlink.message.common.Heartbeat
import scavlink.message.enums.MavAutopilot

object UdpBridge {
  def initializer: ScavlinkInitializer =
    (sup, sctx, actx) =>
      BridgeSettings.option(sctx.config.root).collect {
        case settings if settings.isEnabled =>
          actx.actorOf(UdpBridge.props(settings, sctx.events, sctx.marshallerFactory), "packet-bridge")
      }.toList

  def props(settings: BridgeSettings, events: ConnectionEventBus, marshallerFactory: MarshallerFactory) =
    Props(classOf[UdpBridge], settings, events, marshallerFactory)
}

/**
 * Bridges packet traffic from all connections to a remote UDP port,
 * which may be a server, external GCS app, or another instance of this library.
 *
 * Packets received from all vehicles are forwarded to the port.
 * Duplicate systemIds across connections are remapped to unique ids
 * so the external system sees unique systemIds for all vehicles.
 *
 * If the "allowReceive" setting is true, packets received on the port are
 * forwarded to the target vehicle identified in the message's targetSystem field.
 * This allows the external system to control vehicles in parallel with the local library instance.
 * Messages without a targetSystem field are dropped, since we don't know where to send them.
 *
 * We don't remap the systemId of the external GCS packets, since autopilots typically
 * only accept messages from a single GCS systemId (255,0).
 * That means the vehicle can't distinguish between packets generated by the library and
 * the external GCS, but in practice, it doesn't matter.
 *
 * @author Nick Rossi
 */
class UdpBridge(settings: BridgeSettings, events: ConnectionEventBus, marshallerFactory: MarshallerFactory)
  extends Actor with ActorLogging {

  case class BridgedVehicle(vehicle: Vehicle, tx: FrameSender, marshaller: MessageMarshaller)

  private var links: Map[String, Link] = Map.empty
  private var byVehicle: Map[VehicleId, BridgedVehicle] = Map.empty
  private var byBridgedSystemId: Map[VehicleNumber, BridgedVehicle] = Map.empty

  val remote = settings.address
  val bind = if (settings.allowReceive) {
    Udp.Bind(self, new InetSocketAddress("0.0.0.0", 0))
  } else {
    Udp.SimpleSender
  }


  override def preStart() = {
    events.subscribeToAll(self)
    IO(Udp)(context.system) ! bind
  }

  override def postStop() = {
    events.unsubscribe(self)
    links.values.foreach(_.events.unsubscribe(self))
  }

  def addVehicle(vehicle: Vehicle): BridgedVehicle = {
    val bridgedSystemId = vehicle.info.number.number
    val tx = new FrameSender(bridgedSystemId, vehicle.info.defaultComponentId)
    val bv = BridgedVehicle(vehicle, tx, marshallerFactory(MavAutopilot.ARDUPILOTMEGA))
    byVehicle += vehicle.id -> bv
    byBridgedSystemId += vehicle.info.number -> bv
    bv
  }

  def updateVehicle(id: VehicleId, bv: BridgedVehicle, marshaller: MessageMarshaller): BridgedVehicle = {
    val bvCopy = bv.copy(marshaller = marshaller)
    byVehicle += id -> bvCopy
    byBridgedSystemId += bvCopy.vehicle.info.number -> bvCopy
    bvCopy
  }

  def removeVehicle(id: VehicleId): Unit = {
    byVehicle.get(id) foreach { bv =>
      byVehicle -= id
      byBridgedSystemId -= bv.vehicle.info.number
    }
  }


  def receive: Receive = {
    case Udp.Bound(local) =>
      log.debug(s"Bound on $local")
      log.debug(s"Initializing two-way bridge to $remote")
      context.become(ready(sender(), new FrameReceiver(remote.toString, marshallerFactory)))

    case Udp.SimpleSenderReady =>
      log.debug(s"Initializing forward-only bridge to $remote")
      context.become(ready(sender(), new FrameReceiver(remote.toString, marshallerFactory)))
  }

  def ready(socket: ActorRef, rx: FrameReceiver): Receive = {
    case LinkUp(link) =>
      links += link.address -> link
      link.events.subscribe(self, SubscribeTo.event(classOf[Packet]))

    case LinkDown(link) =>
      links -= link.address
      link.events.unsubscribe(self)

    case VehicleUp(vehicle) =>
      if (vehicle.info.number.group == 1) {
        addVehicle(vehicle)
      }

    case VehicleDown(vehicle) =>
      removeVehicle(vehicle.id)


    case packet: Packet =>
      byVehicle.get(packet.from.id) foreach { _bv =>
        val bv = packet.message match {
          case h: Heartbeat => updateVehicle(packet.from.id, _bv, marshallerFactory(MavAutopilot(h.autopilot)))
          case _ => _bv
        }

        val data = bv.tx.nextMessage(bv.marshaller)(packet.message)
        socket ! Udp.Send(data, remote)
      }


    case Udp.Received(data, `remote`) if settings.allowReceive =>
      rx.receivedData(data) foreach {
        case Right(Packet(from, msg: TargetSystem[_])) =>
          val target = VehicleNumber(1, msg.targetSystem)
          for (bv <- byBridgedSystemId.get(target); link <- links.get(bv.vehicle.link.address)) {
            log.debug(s"  ++> $msg")
            val mappedMsg = msg.setTargetSystem(bv.vehicle.info.systemId)
            link.send(mappedMsg)
          }

        case Right(packet) => log.debug(s"ignored $packet")
        case Left(error) => log.debug(s"$error")
        case _ => //
      }
  }

  override def toString = s"UdpBridge($remote)"
}
