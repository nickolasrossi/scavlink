// Code generated by sbt-mavgen. Manual edits will be overwritten
package scavlink.message.matrixpilot

import scavlink.message._
import scavlink.message.enums._

/**
 * Depreciated but used as a compiler flag.  Do not remove
 * @param targetSystem System ID
 * @param targetComponent Component ID
 */
case class FlexifunctionSet(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Message with TargetComponent[FlexifunctionSet] {
  val _id = 150
  val _name = "FLEXIFUNCTION_SET"
  val _bundle = Bundle.matrixpilot
  def setTargetSystem(systemId: SystemId): FlexifunctionSet = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FlexifunctionSet = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FlexifunctionSet = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FLEXIFUNCTION_SET" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent
}

/**
 * Reqest reading of flexifunction data
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param readReqType Type of flexifunction data requested
 * @param dataIndex index into data where needed
 */
case class FlexifunctionReadReq(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, readReqType: Short = 0, dataIndex: Short = 0)
extends Message with TargetComponent[FlexifunctionReadReq] {
  val _id = 151
  val _name = "FLEXIFUNCTION_READ_REQ"
  val _bundle = Bundle.matrixpilot
  def setTargetSystem(systemId: SystemId): FlexifunctionReadReq = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FlexifunctionReadReq = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FlexifunctionReadReq = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FLEXIFUNCTION_READ_REQ" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " readReqType=" + readReqType + " dataIndex=" + dataIndex
}

/**
 * Flexifunction type and parameters for component at function index from buffer
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param funcIndex Function index
 * @param funcCount Total count of functions
 * @param dataAddress Address in the flexifunction data, Set to 0xFFFF to use address in target memory
 * @param dataSize Size of the
 * @param data Settings data
 */
case class FlexifunctionBufferFunction(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, funcIndex: Short = 0, funcCount: Short = 0, dataAddress: Short = 0, dataSize: Short = 0, data: Vector[Byte] = Vector.fill(48)(0))
extends Message with TargetComponent[FlexifunctionBufferFunction] {
  require(data.length <= 48)
  val _id = 152
  val _name = "FLEXIFUNCTION_BUFFER_FUNCTION"
  val _bundle = Bundle.matrixpilot
  def setTargetSystem(systemId: SystemId): FlexifunctionBufferFunction = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FlexifunctionBufferFunction = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FlexifunctionBufferFunction = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FLEXIFUNCTION_BUFFER_FUNCTION" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " funcIndex=" + funcIndex + " funcCount=" + funcCount + " dataAddress=" + dataAddress + " dataSize=" + dataSize + " data=" + data
}

/**
 * Flexifunction type and parameters for component at function index from buffer
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param funcIndex Function index
 * @param result result of acknowledge, 0=fail, 1=good
 */
case class FlexifunctionBufferFunctionAck(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, funcIndex: Short = 0, result: Short = 0)
extends Message with TargetComponent[FlexifunctionBufferFunctionAck] {
  val _id = 153
  val _name = "FLEXIFUNCTION_BUFFER_FUNCTION_ACK"
  val _bundle = Bundle.matrixpilot
  def setTargetSystem(systemId: SystemId): FlexifunctionBufferFunctionAck = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FlexifunctionBufferFunctionAck = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FlexifunctionBufferFunctionAck = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FLEXIFUNCTION_BUFFER_FUNCTION_ACK" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " funcIndex=" + funcIndex + " result=" + result
}

/**
 * Acknowldge sucess or failure of a flexifunction command
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param directoryType 0=inputs, 1=outputs
 * @param startIndex index of first directory entry to write
 * @param count count of directory entries to write
 * @param directoryData Settings data
 */
case class FlexifunctionDirectory(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, directoryType: Byte = 0, startIndex: Byte = 0, count: Byte = 0, directoryData: Vector[Byte] = Vector.fill(48)(0))
extends Message with TargetComponent[FlexifunctionDirectory] {
  require(directoryData.length <= 48)
  val _id = 155
  val _name = "FLEXIFUNCTION_DIRECTORY"
  val _bundle = Bundle.matrixpilot
  def setTargetSystem(systemId: SystemId): FlexifunctionDirectory = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FlexifunctionDirectory = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FlexifunctionDirectory = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FLEXIFUNCTION_DIRECTORY" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " directoryType=" + directoryType + " startIndex=" + startIndex + " count=" + count + " directoryData=" + directoryData
}

/**
 * Acknowldge sucess or failure of a flexifunction command
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param directoryType 0=inputs, 1=outputs
 * @param startIndex index of first directory entry to write
 * @param count count of directory entries to write
 * @param result result of acknowledge, 0=fail, 1=good
 */
case class FlexifunctionDirectoryAck(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, directoryType: Byte = 0, startIndex: Byte = 0, count: Byte = 0, result: Short = 0)
extends Message with TargetComponent[FlexifunctionDirectoryAck] {
  val _id = 156
  val _name = "FLEXIFUNCTION_DIRECTORY_ACK"
  val _bundle = Bundle.matrixpilot
  def setTargetSystem(systemId: SystemId): FlexifunctionDirectoryAck = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FlexifunctionDirectoryAck = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FlexifunctionDirectoryAck = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FLEXIFUNCTION_DIRECTORY_ACK" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " directoryType=" + directoryType + " startIndex=" + startIndex + " count=" + count + " result=" + result
}

/**
 * Acknowldge sucess or failure of a flexifunction command
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param commandType Flexifunction command type
 */
case class FlexifunctionCommand(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, commandType: Byte = 0)
extends Message with TargetComponent[FlexifunctionCommand] {
  val _id = 157
  val _name = "FLEXIFUNCTION_COMMAND"
  val _bundle = Bundle.matrixpilot
  def setTargetSystem(systemId: SystemId): FlexifunctionCommand = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FlexifunctionCommand = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FlexifunctionCommand = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FLEXIFUNCTION_COMMAND" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " commandType=" + commandType
}

/**
 * Acknowldge sucess or failure of a flexifunction command
 * @param commandType Command acknowledged
 * @param result result of acknowledge
 */
case class FlexifunctionCommandAck(commandType: Short = 0, result: Short = 0)
extends Message {
  val _id = 158
  val _name = "FLEXIFUNCTION_COMMAND_ACK"
  val _bundle = Bundle.matrixpilot
  override def toString = "FLEXIFUNCTION_COMMAND_ACK" + " commandType=" + commandType + " result=" + result
}

/**
 * Backwards compatible MAVLink version of SERIAL_UDB_EXTRA - F2: Format Part A
 * @param sueTime Serial UDB Extra Time
 * @param sueStatus Serial UDB Extra Status
 * @param sueLatitude Serial UDB Extra Latitude
 * @param sueLongitude Serial UDB Extra Longitude
 * @param sueAltitude Serial UDB Extra Altitude
 * @param sueWaypointIndex Serial UDB Extra Waypoint Index
 * @param sueRmat Serial UDB Extra Rmat 0-8
 * @param sueCog Serial UDB Extra GPS Course Over Ground
 * @param sueSog Serial UDB Extra Speed Over Ground
 * @param sueCpuLoad Serial UDB Extra CPU Load
 * @param sueVoltageMilis Serial UDB Extra Voltage in MilliVolts
 * @param sueAirSpeed3DIMU Serial UDB Extra 3D IMU Air Speed
 * @param sueEstimatedWind Serial UDB Extra Estimated Wind 0-2
 * @param sueMagFieldEarth Serial UDB Extra Magnetic Field Earth 0-2
 * @param sueSvs Serial UDB Extra Number of Sattelites in View
 * @param sueHdop Serial UDB Extra GPS Horizontal Dilution of Precision
 */
case class SerialUdbExtraF2A(sueTime: Int = 0, sueStatus: Byte = 0, sueLatitude: Int = 0, sueLongitude: Int = 0, sueAltitude: Int = 0, sueWaypointIndex: Short = 0, sueRmat: Vector[Short] = Vector.fill(9)(0), sueCog: Short = 0, sueSog: Short = 0, sueCpuLoad: Short = 0, sueVoltageMilis: Short = 0, sueAirSpeed3DIMU: Short = 0, sueEstimatedWind: (Short,Short,Short) = (0,0,0), sueMagFieldEarth: (Short,Short,Short) = (0,0,0), sueSvs: Short = 0, sueHdop: Short = 0)
extends Message {
  require(sueRmat.length <= 9)
  val _id = 170
  val _name = "SERIAL_UDB_EXTRA_F2_A"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F2_A" + " sueTime=" + sueTime + " sueStatus=" + sueStatus + " sueLatitude=" + sueLatitude + " sueLongitude=" + sueLongitude + " sueAltitude=" + sueAltitude + " sueWaypointIndex=" + sueWaypointIndex + " sueRmat=" + sueRmat + " sueCog=" + sueCog + " sueSog=" + sueSog + " sueCpuLoad=" + sueCpuLoad + " sueVoltageMilis=" + sueVoltageMilis + " sueAirSpeed3DIMU=" + sueAirSpeed3DIMU + " sueEstimatedWind=" + sueEstimatedWind + " sueMagFieldEarth=" + sueMagFieldEarth + " sueSvs=" + sueSvs + " sueHdop=" + sueHdop
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA - F2: Part B
 * @param sueTime Serial UDB Extra Time
 * @param suePwmInput Serial UDB Extra PWM Input Channel 1-10
 * @param suePwmOutput Serial UDB Extra PWM Output Channel 1-10
 * @param sueImuLocationXYZ Serial UDB Extra IMU Location XYZ
 * @param sueFlags Serial UDB Extra Status Flags
 * @param sueOscFails Serial UDB Extra Oscillator Failure Count
 * @param sueImuVelocityXYZ Serial UDB Extra IMU Velocity XYZ
 * @param sueWaypointGoalXYZ Serial UDB Extra Current Waypoint Goal XYZ
 * @param sueMemoryStackFree Serial UDB Extra Stack Memory Free
 */
case class SerialUdbExtraF2B(sueTime: Int = 0, suePwmInput: Vector[Short] = Vector.fill(10)(0), suePwmOutput: Vector[Short] = Vector.fill(10)(0), sueImuLocationXYZ: (Short,Short,Short) = (0,0,0), sueFlags: Int = 0, sueOscFails: Short = 0, sueImuVelocityXYZ: (Short,Short,Short) = (0,0,0), sueWaypointGoalXYZ: (Short,Short,Short) = (0,0,0), sueMemoryStackFree: Short = 0)
extends Message {
  require(suePwmInput.length <= 10)
  require(suePwmOutput.length <= 10)
  val _id = 171
  val _name = "SERIAL_UDB_EXTRA_F2_B"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F2_B" + " sueTime=" + sueTime + " suePwmInput=" + suePwmInput + " suePwmOutput=" + suePwmOutput + " sueImuLocationXYZ=" + sueImuLocationXYZ + " sueFlags=" + sueFlags + " sueOscFails=" + sueOscFails + " sueImuVelocityXYZ=" + sueImuVelocityXYZ + " sueWaypointGoalXYZ=" + sueWaypointGoalXYZ + " sueMemoryStackFree=" + sueMemoryStackFree
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F4: format
 * @param sueRollStabilizationAilerons Serial UDB Extra Roll Stabilization with Ailerons Enabled
 * @param sueRollStabilizationRudder Serial UDB Extra Roll Stabilization with Rudder Enabled
 * @param suePitchStabilization Serial UDB Extra Pitch Stabilization Enabled
 * @param sueYawStabilizationRudder Serial UDB Extra Yaw Stabilization using Rudder Enabled
 * @param sueYawStabilizationAileron Serial UDB Extra Yaw Stabilization using Ailerons Enabled
 * @param sueAileronNavigation Serial UDB Extra Navigation with Ailerons Enabled
 * @param sueRudderNavigation Serial UDB Extra Navigation with Rudder Enabled
 * @param sueAltitudeholdStabilized Serial UDB Extra Type of Alitude Hold when in Stabilized Mode
 * @param sueAltitudeholdWaypoint Serial UDB Extra Type of Alitude Hold when in Waypoint Mode
 * @param sueRacingMode Serial UDB Extra Firmware racing mode enabled
 */
case class SerialUdbExtraF4(sueRollStabilizationAilerons: Byte = 0, sueRollStabilizationRudder: Byte = 0, suePitchStabilization: Byte = 0, sueYawStabilizationRudder: Byte = 0, sueYawStabilizationAileron: Byte = 0, sueAileronNavigation: Byte = 0, sueRudderNavigation: Byte = 0, sueAltitudeholdStabilized: Byte = 0, sueAltitudeholdWaypoint: Byte = 0, sueRacingMode: Byte = 0)
extends Message {
  val _id = 172
  val _name = "SERIAL_UDB_EXTRA_F4"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F4" + " sueRollStabilizationAilerons=" + sueRollStabilizationAilerons + " sueRollStabilizationRudder=" + sueRollStabilizationRudder + " suePitchStabilization=" + suePitchStabilization + " sueYawStabilizationRudder=" + sueYawStabilizationRudder + " sueYawStabilizationAileron=" + sueYawStabilizationAileron + " sueAileronNavigation=" + sueAileronNavigation + " sueRudderNavigation=" + sueRudderNavigation + " sueAltitudeholdStabilized=" + sueAltitudeholdStabilized + " sueAltitudeholdWaypoint=" + sueAltitudeholdWaypoint + " sueRacingMode=" + sueRacingMode
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F5: format
 * @param sueYawkpAileron Serial UDB YAWKP_AILERON Gain for Proporional control of navigation
 * @param sueYawkdAileron Serial UDB YAWKD_AILERON Gain for Rate control of navigation
 * @param sueRollkp Serial UDB Extra ROLLKP Gain for Proportional control of roll stabilization
 * @param sueRollkd Serial UDB Extra ROLLKD Gain for Rate control of roll stabilization
 * @param sueYawStabilizationAileron YAW_STABILIZATION_AILERON Proportional control
 * @param sueAileronBoost Gain For Boosting Manual Aileron control When Plane Stabilized
 */
case class SerialUdbExtraF5(sueYawkpAileron: Float = 0, sueYawkdAileron: Float = 0, sueRollkp: Float = 0, sueRollkd: Float = 0, sueYawStabilizationAileron: Float = 0, sueAileronBoost: Float = 0)
extends Message {
  val _id = 173
  val _name = "SERIAL_UDB_EXTRA_F5"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F5" + " sueYawkpAileron=" + sueYawkpAileron + " sueYawkdAileron=" + sueYawkdAileron + " sueRollkp=" + sueRollkp + " sueRollkd=" + sueRollkd + " sueYawStabilizationAileron=" + sueYawStabilizationAileron + " sueAileronBoost=" + sueAileronBoost
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F6: format
 * @param suePitchgain Serial UDB Extra PITCHGAIN Proportional Control
 * @param suePitchkd Serial UDB Extra Pitch Rate Control
 * @param sueRudderElevMix Serial UDB Extra Rudder to Elevator Mix
 * @param sueRollElevMix Serial UDB Extra Roll to Elevator Mix
 * @param sueElevatorBoost Gain For Boosting Manual Elevator control When Plane Stabilized
 */
case class SerialUdbExtraF6(suePitchgain: Float = 0, suePitchkd: Float = 0, sueRudderElevMix: Float = 0, sueRollElevMix: Float = 0, sueElevatorBoost: Float = 0)
extends Message {
  val _id = 174
  val _name = "SERIAL_UDB_EXTRA_F6"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F6" + " suePitchgain=" + suePitchgain + " suePitchkd=" + suePitchkd + " sueRudderElevMix=" + sueRudderElevMix + " sueRollElevMix=" + sueRollElevMix + " sueElevatorBoost=" + sueElevatorBoost
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F7: format
 * @param sueYawkpRudder Serial UDB YAWKP_RUDDER Gain for Proporional control of navigation
 * @param sueYawkdRudder Serial UDB YAWKD_RUDDER Gain for Rate control of navigation
 * @param sueRollkpRudder Serial UDB Extra ROLLKP_RUDDER Gain for Proportional control of roll stabilization
 * @param sueRollkdRudder Serial UDB Extra ROLLKD_RUDDER Gain for Rate control of roll stabilization
 * @param sueRudderBoost SERIAL UDB EXTRA Rudder Boost Gain to Manual Control when stabilized
 * @param sueRtlPitchDown Serial UDB Extra Return To Landing - Angle to Pitch Plane Down
 */
case class SerialUdbExtraF7(sueYawkpRudder: Float = 0, sueYawkdRudder: Float = 0, sueRollkpRudder: Float = 0, sueRollkdRudder: Float = 0, sueRudderBoost: Float = 0, sueRtlPitchDown: Float = 0)
extends Message {
  val _id = 175
  val _name = "SERIAL_UDB_EXTRA_F7"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F7" + " sueYawkpRudder=" + sueYawkpRudder + " sueYawkdRudder=" + sueYawkdRudder + " sueRollkpRudder=" + sueRollkpRudder + " sueRollkdRudder=" + sueRollkdRudder + " sueRudderBoost=" + sueRudderBoost + " sueRtlPitchDown=" + sueRtlPitchDown
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F8: format
 * @param sueHeightTargetMax Serial UDB Extra HEIGHT_TARGET_MAX
 * @param sueHeightTargetMin Serial UDB Extra HEIGHT_TARGET_MIN
 * @param sueAltHoldThrottleMin Serial UDB Extra ALT_HOLD_THROTTLE_MIN
 * @param sueAltHoldThrottleMax Serial UDB Extra ALT_HOLD_THROTTLE_MAX
 * @param sueAltHoldPitchMin Serial UDB Extra ALT_HOLD_PITCH_MIN
 * @param sueAltHoldPitchMax Serial UDB Extra ALT_HOLD_PITCH_MAX
 * @param sueAltHoldPitchHigh Serial UDB Extra ALT_HOLD_PITCH_HIGH
 */
case class SerialUdbExtraF8(sueHeightTargetMax: Float = 0, sueHeightTargetMin: Float = 0, sueAltHoldThrottleMin: Float = 0, sueAltHoldThrottleMax: Float = 0, sueAltHoldPitchMin: Float = 0, sueAltHoldPitchMax: Float = 0, sueAltHoldPitchHigh: Float = 0)
extends Message {
  val _id = 176
  val _name = "SERIAL_UDB_EXTRA_F8"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F8" + " sueHeightTargetMax=" + sueHeightTargetMax + " sueHeightTargetMin=" + sueHeightTargetMin + " sueAltHoldThrottleMin=" + sueAltHoldThrottleMin + " sueAltHoldThrottleMax=" + sueAltHoldThrottleMax + " sueAltHoldPitchMin=" + sueAltHoldPitchMin + " sueAltHoldPitchMax=" + sueAltHoldPitchMax + " sueAltHoldPitchHigh=" + sueAltHoldPitchHigh
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F13: format
 * @param sueWeekNo Serial UDB Extra GPS Week Number
 * @param sueLatOrigin Serial UDB Extra MP Origin Latitude
 * @param sueLonOrigin Serial UDB Extra MP Origin Longitude
 * @param sueAltOrigin Serial UDB Extra MP Origin Altitude Above Sea Level
 */
case class SerialUdbExtraF13(sueWeekNo: Short = 0, sueLatOrigin: Int = 0, sueLonOrigin: Int = 0, sueAltOrigin: Int = 0)
extends Message {
  val _id = 177
  val _name = "SERIAL_UDB_EXTRA_F13"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F13" + " sueWeekNo=" + sueWeekNo + " sueLatOrigin=" + sueLatOrigin + " sueLonOrigin=" + sueLonOrigin + " sueAltOrigin=" + sueAltOrigin
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F14: format
 * @param sueWindEstimation Serial UDB Extra Wind Estimation Enabled
 * @param sueGpsType Serial UDB Extra Type of GPS Unit
 * @param sueDr Serial UDB Extra Dead Reckoning Enabled
 * @param sueBoardType Serial UDB Extra Type of UDB Hardware
 * @param sueAirframe Serial UDB Extra Type of Airframe
 * @param sueRcon Serial UDB Extra Reboot Regitster of DSPIC
 * @param sueTrapFlags Serial UDB Extra  Last dspic Trap Flags
 * @param sueTrapSource Serial UDB Extra Type Program Address of Last Trap
 * @param sueOscFailCount Serial UDB Extra Number of Ocillator Failures
 * @param sueClockConfig Serial UDB Extra UDB Internal Clock Configuration
 * @param sueFlightPlanType Serial UDB Extra Type of Flight Plan
 */
case class SerialUdbExtraF14(sueWindEstimation: Byte = 0, sueGpsType: Byte = 0, sueDr: Byte = 0, sueBoardType: Byte = 0, sueAirframe: Byte = 0, sueRcon: Short = 0, sueTrapFlags: Short = 0, sueTrapSource: Int = 0, sueOscFailCount: Short = 0, sueClockConfig: Byte = 0, sueFlightPlanType: Byte = 0)
extends Message {
  val _id = 178
  val _name = "SERIAL_UDB_EXTRA_F14"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F14" + " sueWindEstimation=" + sueWindEstimation + " sueGpsType=" + sueGpsType + " sueDr=" + sueDr + " sueBoardType=" + sueBoardType + " sueAirframe=" + sueAirframe + " sueRcon=" + sueRcon + " sueTrapFlags=" + sueTrapFlags + " sueTrapSource=" + sueTrapSource + " sueOscFailCount=" + sueOscFailCount + " sueClockConfig=" + sueClockConfig + " sueFlightPlanType=" + sueFlightPlanType
}

/**
 * Backwards compatible version of SERIAL_UDB_EXTRA F15 and F16: format
 * @param sueIdVehicleModelName Serial UDB Extra Model Name Of Vehicle
 * @param sueIdVehicleRegistration Serial UDB Extra Registraton Number of Vehicle
 */
case class SerialUdbExtraF15(sueIdVehicleModelName: Vector[Byte] = Vector.fill(40)(0), sueIdVehicleRegistration: Vector[Byte] = Vector.fill(20)(0))
extends Message {
  require(sueIdVehicleModelName.length <= 40)
  require(sueIdVehicleRegistration.length <= 20)
  val _id = 179
  val _name = "SERIAL_UDB_EXTRA_F15"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F15" + " sueIdVehicleModelName=" + sueIdVehicleModelName + " sueIdVehicleRegistration=" + sueIdVehicleRegistration
}

/**
 * @param sueIdLeadPilot Serial UDB Extra Name of Expected Lead Pilot
 * @param sueIdDiyDronesUrl Serial UDB Extra URL of Lead Pilot or Team
 */
case class SerialUdbExtraF16(sueIdLeadPilot: Vector[Byte] = Vector.fill(40)(0), sueIdDiyDronesUrl: Vector[Byte] = Vector.fill(70)(0))
extends Message {
  require(sueIdLeadPilot.length <= 40)
  require(sueIdDiyDronesUrl.length <= 70)
  val _id = 180
  val _name = "SERIAL_UDB_EXTRA_F16"
  val _bundle = Bundle.matrixpilot
  override def toString = "SERIAL_UDB_EXTRA_F16" + " sueIdLeadPilot=" + sueIdLeadPilot + " sueIdDiyDronesUrl=" + sueIdDiyDronesUrl
}

/**
 * The altitude measured by sensors and IMU
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param altGps GPS altitude in meters, expressed as * 1000 (millimeters), above MSL
 * @param altImu IMU altitude above ground in meters, expressed as * 1000 (millimeters)
 * @param altBarometric barometeric altitude above ground in meters, expressed as * 1000 (millimeters)
 * @param altOpticalFlow Optical flow altitude above ground in meters, expressed as * 1000 (millimeters)
 * @param altRangeFinder Rangefinder Altitude above ground in meters, expressed as * 1000 (millimeters)
 * @param altExtra Extra altitude above ground in meters, expressed as * 1000 (millimeters)
 */
case class Altitudes(timeBootMs: Int = 0, altGps: Int = 0, altImu: Int = 0, altBarometric: Int = 0, altOpticalFlow: Int = 0, altRangeFinder: Int = 0, altExtra: Int = 0)
extends Message {
  val _id = 181
  val _name = "ALTITUDES"
  val _bundle = Bundle.matrixpilot
  override def toString = "ALTITUDES" + " timeBootMs=" + timeBootMs + " altGps=" + altGps + " altImu=" + altImu + " altBarometric=" + altBarometric + " altOpticalFlow=" + altOpticalFlow + " altRangeFinder=" + altRangeFinder + " altExtra=" + altExtra
}

/**
 * The airspeed measured by sensors and IMU
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param airspeedImu Airspeed estimate from IMU, cm/s
 * @param airspeedPitot Pitot measured forward airpseed, cm/s
 * @param airspeedHotWire Hot wire anenometer measured airspeed, cm/s
 * @param airspeedUltrasonic Ultrasonic measured airspeed, cm/s
 * @param aoa Angle of attack sensor, degrees * 10
 * @param aoy Yaw angle sensor, degrees * 10
 */
case class Airspeeds(timeBootMs: Int = 0, airspeedImu: Short = 0, airspeedPitot: Short = 0, airspeedHotWire: Short = 0, airspeedUltrasonic: Short = 0, aoa: Short = 0, aoy: Short = 0)
extends Message {
  val _id = 182
  val _name = "AIRSPEEDS"
  val _bundle = Bundle.matrixpilot
  override def toString = "AIRSPEEDS" + " timeBootMs=" + timeBootMs + " airspeedImu=" + airspeedImu + " airspeedPitot=" + airspeedPitot + " airspeedHotWire=" + airspeedHotWire + " airspeedUltrasonic=" + airspeedUltrasonic + " aoa=" + aoa + " aoy=" + aoy
}
