// Code generated by sbt-mavgen. Manual edits will be overwritten
package scavlink.message.common

import scavlink.message._
import scavlink.message.enums.MavCmd
import scavlink.coord.Coordinates
import scavlink.coord.Geo

/**
 * Navigate to MISSION.
 * @param holdTime Hold time in decimal seconds. (ignored by fixed wing, time to stay at MISSION for rotary wing)
 * @param acceptanceRadius Acceptance radius in meters (if the sphere with this radius is hit, the MISSION counts as reached)
 * @param param3 0 to pass through the WP, if > 0 radius in meters to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.
 * @param desiredYawAngle Desired yaw angle at MISSION (rotary wing)
 * @param location Latitude / Longitude / Altitude
 */
case class NavWaypoint(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, holdTime: Float = 0, acceptanceRadius: Float = 0, param3: Float = 0, desiredYawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavWaypoint] {
  val cmd = MavCmd(16)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = holdTime, param2 = acceptanceRadius, param3 = param3, param4 = desiredYawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " holdTime=" + holdTime + " acceptanceRadius=" + acceptanceRadius + " param3=" + param3 + " desiredYawAngle=" + desiredYawAngle + " location=" + location 
}

object NavWaypoint {
  def apply(loc: Coordinates): NavWaypoint = NavWaypoint(location = loc)
}

/**
 * Loiter around this MISSION an unlimited amount of time
 * @param radiusAroundMission Radius around MISSION, in meters. If positive loiter clockwise, else counter-clockwise
 * @param desiredYawAngle Desired yaw angle.
 * @param location Latitude / Longitude / Altitude
 */
case class NavLoiterUnlim(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, radiusAroundMission: Float = 0, desiredYawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavLoiterUnlim] {
  val cmd = MavCmd(17)
  val message = CommandLong(targetSystem, targetComponent, cmd, param3 = radiusAroundMission, param4 = desiredYawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " radiusAroundMission=" + radiusAroundMission + " desiredYawAngle=" + desiredYawAngle + " location=" + location 
}

object NavLoiterUnlim {
  def apply(loc: Coordinates): NavLoiterUnlim = NavLoiterUnlim(location = loc)
}

/**
 * Loiter around this MISSION for X turns
 * @param turns Turns
 * @param radiusAroundMission Radius around MISSION, in meters. If positive loiter clockwise, else counter-clockwise
 * @param desiredYawAngle Desired yaw angle.
 * @param location Latitude / Longitude / Altitude
 */
case class NavLoiterTurns(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, turns: Float = 0, radiusAroundMission: Float = 0, desiredYawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavLoiterTurns] {
  val cmd = MavCmd(18)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = turns, param3 = radiusAroundMission, param4 = desiredYawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " turns=" + turns + " radiusAroundMission=" + radiusAroundMission + " desiredYawAngle=" + desiredYawAngle + " location=" + location 
}

object NavLoiterTurns {
  def apply(loc: Coordinates): NavLoiterTurns = NavLoiterTurns(location = loc)
}

/**
 * Loiter around this MISSION for X seconds
 * @param seconds Seconds (decimal)
 * @param radiusAroundMission Radius around MISSION, in meters. If positive loiter clockwise, else counter-clockwise
 * @param desiredYawAngle Desired yaw angle.
 * @param location Latitude / Longitude / Altitude
 */
case class NavLoiterTime(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, seconds: Float = 0, radiusAroundMission: Float = 0, desiredYawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavLoiterTime] {
  val cmd = MavCmd(19)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = seconds, param3 = radiusAroundMission, param4 = desiredYawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " seconds=" + seconds + " radiusAroundMission=" + radiusAroundMission + " desiredYawAngle=" + desiredYawAngle + " location=" + location 
}

object NavLoiterTime {
  def apply(loc: Coordinates): NavLoiterTime = NavLoiterTime(location = loc)
}

/**
 * Return to launch location
 */
case class NavReturnToLaunch(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Command {
  val cmd = MavCmd(20)
  val message = CommandLong(targetSystem, targetComponent, cmd)
  override def toString = cmd.toString 
}

/**
 * Land at location
 * @param desiredYawAngle Desired yaw angle.
 * @param location Latitude / Longitude / Altitude
 */
case class NavLand(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, desiredYawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavLand] {
  val cmd = MavCmd(21)
  val message = CommandLong(targetSystem, targetComponent, cmd, param4 = desiredYawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " desiredYawAngle=" + desiredYawAngle + " location=" + location 
}

object NavLand {
  def apply(loc: Coordinates): NavLand = NavLand(location = loc)
}

/**
 * Takeoff from ground / hand
 * @param minimumPitch Minimum pitch (if airspeed sensor present), desired pitch without sensor
 * @param yawAngle Yaw angle (if magnetometer present), ignored without magnetometer
 * @param location Latitude / Longitude / Altitude
 */
case class NavTakeoff(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, minimumPitch: Float = 0, yawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavTakeoff] {
  val cmd = MavCmd(22)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = minimumPitch, param4 = yawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " minimumPitch=" + minimumPitch + " yawAngle=" + yawAngle + " location=" + location 
}

object NavTakeoff {
  def apply(loc: Coordinates): NavTakeoff = NavTakeoff(location = loc)
}

/**
 * Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached.
 * @param desiredAltitude Desired altitude in meters
 */
case class NavContinueAndChangeAlt(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, desiredAltitude: Float = 0)
extends Command {
  val cmd = MavCmd(30)
  val message = CommandLong(targetSystem, targetComponent, cmd, param7 = desiredAltitude)
  override def toString = cmd.toString + " desiredAltitude=" + desiredAltitude 
}

/**
 * Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras.
 * @param regionOfInteresetMode Region of intereset mode. (see MAV_ROI enum)
 * @param missionIndexOrTargetId MISSION index/ target ID. (see MAV_ROI enum)
 * @param roiIndex ROI index (allows a vehicle to manage multiple ROI's)
 * @param location x the location of the fixed ROI (see MAV_FRAME) / y / z
 */
case class NavRoi(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, regionOfInteresetMode: Float = 0, missionIndexOrTargetId: Float = 0, roiIndex: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavRoi] {
  val cmd = MavCmd(80)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = regionOfInteresetMode, param2 = missionIndexOrTargetId, param3 = roiIndex, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " regionOfInteresetMode=" + regionOfInteresetMode + " missionIndexOrTargetId=" + missionIndexOrTargetId + " roiIndex=" + roiIndex + " location=" + location 
}

object NavRoi {
  def apply(loc: Coordinates): NavRoi = NavRoi(location = loc)
}

/**
 * Control autonomous path planning on the MAV.
 * @param param1 0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning
 * @param param2 0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid
 * @param yawAngle Yaw angle at goal, in compass degrees, [0..360]
 * @param location Latitude/X of goal / Longitude/Y of goal / Altitude/Z of goal
 */
case class NavPathplanning(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, param1: Float = 0, param2: Float = 0, yawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavPathplanning] {
  val cmd = MavCmd(81)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = param1, param2 = param2, param4 = yawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " param1=" + param1 + " param2=" + param2 + " yawAngle=" + yawAngle + " location=" + location 
}

object NavPathplanning {
  def apply(loc: Coordinates): NavPathplanning = NavPathplanning(location = loc)
}

/**
 * Navigate to MISSION using a spline path.
 * @param holdTime Hold time in decimal seconds. (ignored by fixed wing, time to stay at MISSION for rotary wing)
 * @param location Latitude/X of goal / Longitude/Y of goal / Altitude/Z of goal
 */
case class NavSplineWaypoint(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, holdTime: Float = 0, location: Coordinates = Geo())
extends Command with Location[NavSplineWaypoint] {
  val cmd = MavCmd(82)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = holdTime, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " holdTime=" + holdTime + " location=" + location 
}

object NavSplineWaypoint {
  def apply(loc: Coordinates): NavSplineWaypoint = NavSplineWaypoint(location = loc)
}

/**
 * hand control over to an external controller
 * @param onOrOff On / Off (> 0.5f on)
 */
case class NavGuidedEnable(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, onOrOff: Float = 0)
extends Command {
  val cmd = MavCmd(92)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = onOrOff)
  override def toString = cmd.toString + " onOrOff=" + onOrOff 
}

/**
 * Delay mission state machine.
 * @param delay Delay in seconds (decimal)
 */
case class ConditionDelay(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, delay: Float = 0)
extends Command {
  val cmd = MavCmd(112)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = delay)
  override def toString = cmd.toString + " delay=" + delay 
}

/**
 * Ascend/descend at rate.  Delay mission state machine until desired altitude reached.
 * @param descentOrAscendRate Descent / Ascend rate (m/s)
 * @param finishAltitude Finish Altitude
 */
case class ConditionChangeAlt(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, descentOrAscendRate: Float = 0, finishAltitude: Float = 0)
extends Command {
  val cmd = MavCmd(113)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = descentOrAscendRate, param7 = finishAltitude)
  override def toString = cmd.toString + " descentOrAscendRate=" + descentOrAscendRate + " finishAltitude=" + finishAltitude 
}

/**
 * Delay mission state machine until within desired distance of next NAV point.
 * @param distance Distance (meters)
 */
case class ConditionDistance(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, distance: Float = 0)
extends Command {
  val cmd = MavCmd(114)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = distance)
  override def toString = cmd.toString + " distance=" + distance 
}

/**
 * Reach a certain target angle.
 * @param targetAngle target angle: [0-360], 0 is north
 * @param speedDuringYawChange speed during yaw change:[deg per second]
 * @param direction direction: negative: counter clockwise, positive: clockwise [-1,1]
 * @param relativeOffsetOrAbsoluteAngle relative offset or absolute angle: [ 1,0]
 */
case class ConditionYaw(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, targetAngle: Float = 0, speedDuringYawChange: Float = 0, direction: Float = 0, relativeOffsetOrAbsoluteAngle: Float = 0)
extends Command {
  val cmd = MavCmd(115)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = targetAngle, param2 = speedDuringYawChange, param3 = direction, param4 = relativeOffsetOrAbsoluteAngle)
  override def toString = cmd.toString + " targetAngle=" + targetAngle + " speedDuringYawChange=" + speedDuringYawChange + " direction=" + direction + " relativeOffsetOrAbsoluteAngle=" + relativeOffsetOrAbsoluteAngle 
}

/**
 * Set system mode.
 * @param mode Mode, as defined by ENUM MAV_MODE
 * @param customModeThisIsSystemSpecific Custom mode - this is system specific, please refer to the individual autopilot specifications for details.
 */
case class DoSetMode(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, mode: Float = 0, customModeThisIsSystemSpecific: Float = 0)
extends Command {
  val cmd = MavCmd(176)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = mode, param2 = customModeThisIsSystemSpecific)
  override def toString = cmd.toString + " mode=" + mode + " customModeThisIsSystemSpecific=" + customModeThisIsSystemSpecific 
}

/**
 * Jump to the desired command in the mission list.  Repeat this action only the specified number of times
 * @param sequenceNumber Sequence number
 * @param repeatCount Repeat count
 */
case class DoJump(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, sequenceNumber: Float = 0, repeatCount: Float = 0)
extends Command {
  val cmd = MavCmd(177)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = sequenceNumber, param2 = repeatCount)
  override def toString = cmd.toString + " sequenceNumber=" + sequenceNumber + " repeatCount=" + repeatCount 
}

/**
 * Change speed and/or throttle set points.
 * @param speedType Speed type (0=Airspeed, 1=Ground Speed)
 * @param speed Speed  (m/s, -1 indicates no change)
 * @param throttle Throttle  ( Percent, -1 indicates no change)
 */
case class DoChangeSpeed(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, speedType: Float = 0, speed: Float = 0, throttle: Float = 0)
extends Command {
  val cmd = MavCmd(178)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = speedType, param2 = speed, param3 = throttle)
  override def toString = cmd.toString + " speedType=" + speedType + " speed=" + speed + " throttle=" + throttle 
}

/**
 * Changes the home location either to the current location or a specified location.
 * @param useCurrent Use current (1=use current location, 0=use specified location)
 * @param location Latitude / Longitude / Altitude
 */
case class DoSetHome(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, useCurrent: Float = 0, location: Coordinates = Geo())
extends Command with Location[DoSetHome] {
  val cmd = MavCmd(179)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = useCurrent, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " useCurrent=" + useCurrent + " location=" + location 
}

object DoSetHome {
  def apply(loc: Coordinates): DoSetHome = DoSetHome(location = loc)
}

/**
 * Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter.
 * @param parameterNumber Parameter number
 * @param parameterValue Parameter value
 */
case class DoSetParameter(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, parameterNumber: Float = 0, parameterValue: Float = 0)
extends Command {
  val cmd = MavCmd(180)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = parameterNumber, param2 = parameterValue)
  override def toString = cmd.toString + " parameterNumber=" + parameterNumber + " parameterValue=" + parameterValue 
}

/**
 * Set a relay to a condition.
 * @param relayNumber Relay number
 * @param setting Setting (1=on, 0=off, others possible depending on system hardware)
 */
case class DoSetRelay(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, relayNumber: Float = 0, setting: Float = 0)
extends Command {
  val cmd = MavCmd(181)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = relayNumber, param2 = setting)
  override def toString = cmd.toString + " relayNumber=" + relayNumber + " setting=" + setting 
}

/**
 * Cycle a relay on and off for a desired number of cyles with a desired period.
 * @param relayNumber Relay number
 * @param cycleCount Cycle count
 * @param cycleTime Cycle time (seconds, decimal)
 */
case class DoRepeatRelay(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, relayNumber: Float = 0, cycleCount: Float = 0, cycleTime: Float = 0)
extends Command {
  val cmd = MavCmd(182)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = relayNumber, param2 = cycleCount, param3 = cycleTime)
  override def toString = cmd.toString + " relayNumber=" + relayNumber + " cycleCount=" + cycleCount + " cycleTime=" + cycleTime 
}

/**
 * Set a servo to a desired PWM value.
 * @param servoNumber Servo number
 * @param pwm PWM (microseconds, 1000 to 2000 typical)
 */
case class DoSetServo(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, servoNumber: Float = 0, pwm: Float = 0)
extends Command {
  val cmd = MavCmd(183)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = servoNumber, param2 = pwm)
  override def toString = cmd.toString + " servoNumber=" + servoNumber + " pwm=" + pwm 
}

/**
 * Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period.
 * @param servoNumber Servo number
 * @param pwm PWM (microseconds, 1000 to 2000 typical)
 * @param cycleCount Cycle count
 * @param cycleTime Cycle time (seconds)
 */
case class DoRepeatServo(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, servoNumber: Float = 0, pwm: Float = 0, cycleCount: Float = 0, cycleTime: Float = 0)
extends Command {
  val cmd = MavCmd(184)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = servoNumber, param2 = pwm, param3 = cycleCount, param4 = cycleTime)
  override def toString = cmd.toString + " servoNumber=" + servoNumber + " pwm=" + pwm + " cycleCount=" + cycleCount + " cycleTime=" + cycleTime 
}

/**
 * Terminate flight immediately
 * @param flightTerminationActivated Flight termination activated if > 0.5
 */
case class DoFlighttermination(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, flightTerminationActivated: Float = 0)
extends Command {
  val cmd = MavCmd(185)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = flightTerminationActivated)
  override def toString = cmd.toString + " flightTerminationActivated=" + flightTerminationActivated 
}

/**
 * Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will be used. The Latitude/Longitude is optional, and may be set to 0/0 if not needed. If specified then it will be used to help find the closest landing sequence.
 * @param latitude Latitude
 * @param longitude Longitude
 */
case class DoLandStart(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, latitude: Float = 0, longitude: Float = 0)
extends Command {
  val cmd = MavCmd(189)
  val message = CommandLong(targetSystem, targetComponent, cmd, param5 = latitude, param6 = longitude)
  override def toString = cmd.toString + " latitude=" + latitude + " longitude=" + longitude 
}

/**
 * Mission command to perform a landing from a rally point.
 * @param breakAltitude Break altitude (meters)
 * @param landingSpeed Landing speed (m/s)
 */
case class DoRallyLand(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, breakAltitude: Float = 0, landingSpeed: Float = 0)
extends Command {
  val cmd = MavCmd(190)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = breakAltitude, param2 = landingSpeed)
  override def toString = cmd.toString + " breakAltitude=" + breakAltitude + " landingSpeed=" + landingSpeed 
}

/**
 * Mission command to safely abort an autonmous landing.
 * @param altitude Altitude (meters)
 */
case class DoGoAround(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, altitude: Float = 0)
extends Command {
  val cmd = MavCmd(191)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = altitude)
  override def toString = cmd.toString + " altitude=" + altitude 
}

/**
 * Control onboard camera system.
 * @param cameraId Camera ID (-1 for all)
 * @param transmission Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw
 * @param transmissionMode Transmission mode: 0: video stream, >0: single images every n seconds (decimal)
 * @param recording Recording: 0: disabled, 1: enabled compressed, 2: enabled raw
 */
case class DoControlVideo(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, cameraId: Float = 0, transmission: Float = 0, transmissionMode: Float = 0, recording: Float = 0)
extends Command {
  val cmd = MavCmd(200)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = cameraId, param2 = transmission, param3 = transmissionMode, param4 = recording)
  override def toString = cmd.toString + " cameraId=" + cameraId + " transmission=" + transmission + " transmissionMode=" + transmissionMode + " recording=" + recording 
}

/**
 * Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras.
 * @param regionOfInteresetMode Region of intereset mode. (see MAV_ROI enum)
 * @param missionIndexOrTargetId MISSION index/ target ID. (see MAV_ROI enum)
 * @param roiIndex ROI index (allows a vehicle to manage multiple ROI's)
 * @param location x the location of the fixed ROI (see MAV_FRAME) / y / z
 */
case class DoSetRoi(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, regionOfInteresetMode: Float = 0, missionIndexOrTargetId: Float = 0, roiIndex: Float = 0, location: Coordinates = Geo())
extends Command with Location[DoSetRoi] {
  val cmd = MavCmd(201)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = regionOfInteresetMode, param2 = missionIndexOrTargetId, param3 = roiIndex, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " regionOfInteresetMode=" + regionOfInteresetMode + " missionIndexOrTargetId=" + missionIndexOrTargetId + " roiIndex=" + roiIndex + " location=" + location 
}

object DoSetRoi {
  def apply(loc: Coordinates): DoSetRoi = DoSetRoi(location = loc)
}

/**
 * Mission command to configure an on-board camera controller system.
 * @param modes Modes: P, TV, AV, M, Etc
 * @param shutterSpeed Shutter speed: Divisor number for one second
 * @param aperture Aperture: F stop number
 * @param isoNumber ISO number e.g. 80, 100, 200, Etc
 * @param exposureTypeEnumerator Exposure type enumerator
 * @param commandIdentity Command Identity
 * @param mainEngineCutOffTimeBeforeCameraTrigger Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off)
 */
case class DoDigicamConfigure(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, modes: Float = 0, shutterSpeed: Float = 0, aperture: Float = 0, isoNumber: Float = 0, exposureTypeEnumerator: Float = 0, commandIdentity: Float = 0, mainEngineCutOffTimeBeforeCameraTrigger: Float = 0)
extends Command {
  val cmd = MavCmd(202)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = modes, param2 = shutterSpeed, param3 = aperture, param4 = isoNumber, param5 = exposureTypeEnumerator, param6 = commandIdentity, param7 = mainEngineCutOffTimeBeforeCameraTrigger)
  override def toString = cmd.toString + " modes=" + modes + " shutterSpeed=" + shutterSpeed + " aperture=" + aperture + " isoNumber=" + isoNumber + " exposureTypeEnumerator=" + exposureTypeEnumerator + " commandIdentity=" + commandIdentity + " mainEngineCutOffTimeBeforeCameraTrigger=" + mainEngineCutOffTimeBeforeCameraTrigger 
}

/**
 * Mission command to control an on-board camera controller system.
 * @param sessionControl Session control e.g. show/hide lens
 * @param zoomAbsolutePosition Zoom's absolute position
 * @param zoomingStepValue Zooming step value to offset zoom from the current position
 * @param focusLocking Focus Locking, Unlocking or Re-locking
 * @param shootingCommand Shooting Command
 * @param commandIdentity Command Identity
 */
case class DoDigicamControl(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, sessionControl: Float = 0, zoomAbsolutePosition: Float = 0, zoomingStepValue: Float = 0, focusLocking: Float = 0, shootingCommand: Float = 0, commandIdentity: Float = 0)
extends Command {
  val cmd = MavCmd(203)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = sessionControl, param2 = zoomAbsolutePosition, param3 = zoomingStepValue, param4 = focusLocking, param5 = shootingCommand, param6 = commandIdentity)
  override def toString = cmd.toString + " sessionControl=" + sessionControl + " zoomAbsolutePosition=" + zoomAbsolutePosition + " zoomingStepValue=" + zoomingStepValue + " focusLocking=" + focusLocking + " shootingCommand=" + shootingCommand + " commandIdentity=" + commandIdentity 
}

/**
 * Mission command to configure a camera or antenna mount
 * @param mountOperationMode Mount operation mode (see MAV_MOUNT_MODE enum)
 * @param stabilizeRoll stabilize roll? (1 = yes, 0 = no)
 * @param stabilizePitch stabilize pitch? (1 = yes, 0 = no)
 * @param stabilizeYaw stabilize yaw? (1 = yes, 0 = no)
 */
case class DoMountConfigure(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, mountOperationMode: Float = 0, stabilizeRoll: Float = 0, stabilizePitch: Float = 0, stabilizeYaw: Float = 0)
extends Command {
  val cmd = MavCmd(204)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = mountOperationMode, param2 = stabilizeRoll, param3 = stabilizePitch, param4 = stabilizeYaw)
  override def toString = cmd.toString + " mountOperationMode=" + mountOperationMode + " stabilizeRoll=" + stabilizeRoll + " stabilizePitch=" + stabilizePitch + " stabilizeYaw=" + stabilizeYaw 
}

/**
 * Mission command to control a camera or antenna mount
 * @param pitchOrLat pitch or lat in degrees, depending on mount mode.
 * @param rollOrLon roll or lon in degrees depending on mount mode
 * @param yawOrAlt yaw or alt (in meters) depending on mount mode
 * @param mavMountModeEnumValue MAV_MOUNT_MODE enum value
 */
case class DoMountControl(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, pitchOrLat: Float = 0, rollOrLon: Float = 0, yawOrAlt: Float = 0, mavMountModeEnumValue: Float = 0)
extends Command {
  val cmd = MavCmd(205)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = pitchOrLat, param2 = rollOrLon, param3 = yawOrAlt, param7 = mavMountModeEnumValue)
  override def toString = cmd.toString + " pitchOrLat=" + pitchOrLat + " rollOrLon=" + rollOrLon + " yawOrAlt=" + yawOrAlt + " mavMountModeEnumValue=" + mavMountModeEnumValue 
}

/**
 * Mission command to set CAM_TRIGG_DIST for this flight
 * @param cameraTriggerDistance Camera trigger distance (meters)
 */
case class DoSetCamTriggDist(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, cameraTriggerDistance: Float = 0)
extends Command {
  val cmd = MavCmd(206)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = cameraTriggerDistance)
  override def toString = cmd.toString + " cameraTriggerDistance=" + cameraTriggerDistance 
}

/**
 * Mission command to enable the geofence
 * @param enable enable? (0=disable, 1=enable)
 */
case class DoFenceEnable(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, enable: Float = 0)
extends Command {
  val cmd = MavCmd(207)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = enable)
  override def toString = cmd.toString + " enable=" + enable 
}

/**
 * Mission command to trigger a parachute
 * @param action action (0=disable, 1=enable, 2=release, for some systems see PARACHUTE_ACTION enum, not in general message set.)
 */
case class DoParachute(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, action: Float = 0)
extends Command {
  val cmd = MavCmd(208)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = action)
  override def toString = cmd.toString + " action=" + action 
}

/**
 * Change to/from inverted flight
 * @param inverted inverted (0=normal, 1=inverted)
 */
case class DoInvertedFlight(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, inverted: Float = 0)
extends Command {
  val cmd = MavCmd(210)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = inverted)
  override def toString = cmd.toString + " inverted=" + inverted 
}

/**
 * Mission command to control a camera or antenna mount, using a quaternion as reference.
 * @param q1QuaternionParam q1 - quaternion param #1, w (1 in null-rotation)
 * @param q2QuaternionParam q2 - quaternion param #2, x (0 in null-rotation)
 * @param q3QuaternionParam q3 - quaternion param #3, y (0 in null-rotation)
 * @param q4QuaternionParam q4 - quaternion param #4, z (0 in null-rotation)
 */
case class DoMountControlQuat(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, q1QuaternionParam: Float = 0, q2QuaternionParam: Float = 0, q3QuaternionParam: Float = 0, q4QuaternionParam: Float = 0)
extends Command {
  val cmd = MavCmd(220)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = q1QuaternionParam, param2 = q2QuaternionParam, param3 = q3QuaternionParam, param4 = q4QuaternionParam)
  override def toString = cmd.toString + " q1QuaternionParam=" + q1QuaternionParam + " q2QuaternionParam=" + q2QuaternionParam + " q3QuaternionParam=" + q3QuaternionParam + " q4QuaternionParam=" + q4QuaternionParam 
}

/**
 * set id of master controller
 * @param systemId System ID
 * @param componentId Component ID
 */
case class DoGuidedMaster(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, systemId: Float = 0, componentId: Float = 0)
extends Command {
  val cmd = MavCmd(221)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = systemId, param2 = componentId)
  override def toString = cmd.toString + " systemId=" + systemId + " componentId=" + componentId 
}

/**
 * set limits for external control
 * @param timeoutMaximumTime timeout - maximum time (in seconds) that external controller will be allowed to control vehicle. 0 means no timeout
 * @param absoluteAltitudeMin absolute altitude min (in meters, WGS84) - if vehicle moves below this alt, the command will be aborted and the mission will continue.  0 means no lower altitude limit
 * @param absoluteAltitudeMax absolute altitude max (in meters)- if vehicle moves above this alt, the command will be aborted and the mission will continue.  0 means no upper altitude limit
 * @param horizontalMoveLimit horizontal move limit (in meters, WGS84) - if vehicle moves more than this distance from it's location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal altitude limit
 */
case class DoGuidedLimits(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, timeoutMaximumTime: Float = 0, absoluteAltitudeMin: Float = 0, absoluteAltitudeMax: Float = 0, horizontalMoveLimit: Float = 0)
extends Command {
  val cmd = MavCmd(222)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = timeoutMaximumTime, param2 = absoluteAltitudeMin, param3 = absoluteAltitudeMax, param4 = horizontalMoveLimit)
  override def toString = cmd.toString + " timeoutMaximumTime=" + timeoutMaximumTime + " absoluteAltitudeMin=" + absoluteAltitudeMin + " absoluteAltitudeMax=" + absoluteAltitudeMax + " horizontalMoveLimit=" + horizontalMoveLimit 
}

/**
 * Trigger calibration. This command will be only accepted if in pre-flight mode.
 * @param gyroCalibration Gyro calibration: 0: no, 1: yes
 * @param magnetometerCalibration Magnetometer calibration: 0: no, 1: yes
 * @param groundPressure Ground pressure: 0: no, 1: yes
 * @param radioCalibration Radio calibration: 0: no, 1: yes
 * @param accelerometerCalibration Accelerometer calibration: 0: no, 1: yes
 * @param compassOrMotorInterferenceCalibration Compass/Motor interference calibration: 0: no, 1: yes
 */
case class PreflightCalibration(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, gyroCalibration: Float = 0, magnetometerCalibration: Float = 0, groundPressure: Float = 0, radioCalibration: Float = 0, accelerometerCalibration: Float = 0, compassOrMotorInterferenceCalibration: Float = 0)
extends Command {
  val cmd = MavCmd(241)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = gyroCalibration, param2 = magnetometerCalibration, param3 = groundPressure, param4 = radioCalibration, param5 = accelerometerCalibration, param6 = compassOrMotorInterferenceCalibration)
  override def toString = cmd.toString + " gyroCalibration=" + gyroCalibration + " magnetometerCalibration=" + magnetometerCalibration + " groundPressure=" + groundPressure + " radioCalibration=" + radioCalibration + " accelerometerCalibration=" + accelerometerCalibration + " compassOrMotorInterferenceCalibration=" + compassOrMotorInterferenceCalibration 
}

/**
 * Set sensor offsets. This command will be only accepted if in pre-flight mode.
 * @param sensor Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer
 * @param xAxisOffset X axis offset (or generic dimension 1), in the sensor's raw units
 * @param yAxisOffset Y axis offset (or generic dimension 2), in the sensor's raw units
 * @param zAxisOffset Z axis offset (or generic dimension 3), in the sensor's raw units
 * @param genericDimension4 Generic dimension 4, in the sensor's raw units
 * @param genericDimension5 Generic dimension 5, in the sensor's raw units
 * @param genericDimension6 Generic dimension 6, in the sensor's raw units
 */
case class PreflightSetSensorOffsets(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, sensor: Float = 0, xAxisOffset: Float = 0, yAxisOffset: Float = 0, zAxisOffset: Float = 0, genericDimension4: Float = 0, genericDimension5: Float = 0, genericDimension6: Float = 0)
extends Command {
  val cmd = MavCmd(242)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = sensor, param2 = xAxisOffset, param3 = yAxisOffset, param4 = zAxisOffset, param5 = genericDimension4, param6 = genericDimension5, param7 = genericDimension6)
  override def toString = cmd.toString + " sensor=" + sensor + " xAxisOffset=" + xAxisOffset + " yAxisOffset=" + yAxisOffset + " zAxisOffset=" + zAxisOffset + " genericDimension4=" + genericDimension4 + " genericDimension5=" + genericDimension5 + " genericDimension6=" + genericDimension6 
}

/**
 * Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode.
 * @param parameterStorage Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM
 * @param missionStorage Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM
 */
case class PreflightStorage(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, parameterStorage: Float = 0, missionStorage: Float = 0)
extends Command {
  val cmd = MavCmd(245)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = parameterStorage, param2 = missionStorage)
  override def toString = cmd.toString + " parameterStorage=" + parameterStorage + " missionStorage=" + missionStorage 
}

/**
 * Request the reboot or shutdown of system components.
 * @param param1 0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot.
 * @param param2 0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer.
 */
case class PreflightRebootShutdown(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, param1: Float = 0, param2: Float = 0)
extends Command {
  val cmd = MavCmd(246)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = param1, param2 = param2)
  override def toString = cmd.toString + " param1=" + param1 + " param2=" + param2 
}

/**
 * Hold / continue the current action
 * @param mavGotoDoHold MAV_GOTO_DO_HOLD: hold MAV_GOTO_DO_CONTINUE: continue with next item in mission plan
 * @param mavGotoHoldAtCurrentPosition MAV_GOTO_HOLD_AT_CURRENT_POSITION: Hold at current position MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position
 * @param mavFrameCoordinateFrameOfHoldPoint MAV_FRAME coordinate frame of hold point
 * @param desiredYawAngle Desired yaw angle in degrees
 * @param location Latitude / X position / Longitude / Y position / Altitude / Z position
 */
case class OverrideGoto(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, mavGotoDoHold: Float = 0, mavGotoHoldAtCurrentPosition: Float = 0, mavFrameCoordinateFrameOfHoldPoint: Float = 0, desiredYawAngle: Float = 0, location: Coordinates = Geo())
extends Command with Location[OverrideGoto] {
  val cmd = MavCmd(252)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = mavGotoDoHold, param2 = mavGotoHoldAtCurrentPosition, param3 = mavFrameCoordinateFrameOfHoldPoint, param4 = desiredYawAngle, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " mavGotoDoHold=" + mavGotoDoHold + " mavGotoHoldAtCurrentPosition=" + mavGotoHoldAtCurrentPosition + " mavFrameCoordinateFrameOfHoldPoint=" + mavFrameCoordinateFrameOfHoldPoint + " desiredYawAngle=" + desiredYawAngle + " location=" + location 
}

object OverrideGoto {
  def apply(loc: Coordinates): OverrideGoto = OverrideGoto(location = loc)
}

/**
 * start running a mission
 * @param firstItem first_item: the first mission item to run
 * @param lastItem last_item:  the last mission item to run (after this item is run, the mission ends)
 */
case class MissionStart(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, firstItem: Float = 0, lastItem: Float = 0)
extends Command {
  val cmd = MavCmd(300)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = firstItem, param2 = lastItem)
  override def toString = cmd.toString + " firstItem=" + firstItem + " lastItem=" + lastItem 
}

/**
 * Arms / Disarms a component
 * @param param1 1 to arm, 0 to disarm
 */
case class ComponentArmDisarm(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, param1: Float = 0)
extends Command {
  val cmd = MavCmd(400)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = param1)
  override def toString = cmd.toString + " param1=" + param1 
}

/**
 * Starts receiver pairing
 * @param param1 0:Spektrum
 * @param param2 0:Spektrum DSM2, 1:Spektrum DSMX
 */
case class StartRxPair(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, param1: Float = 0, param2: Float = 0)
extends Command {
  val cmd = MavCmd(500)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = param1, param2 = param2)
  override def toString = cmd.toString + " param1=" + param1 + " param2=" + param2 
}

/**
 * Start image capture sequence
 * @param durationBetweenTwoConsecutivePictures Duration between two consecutive pictures (in seconds)
 * @param numberOfImages Number of images to capture total - 0 for unlimited capture
 * @param resolution Resolution in megapixels (0.3 for 640x480, 1.3 for 1280x720, etc)
 */
case class ImageStartCapture(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, durationBetweenTwoConsecutivePictures: Float = 0, numberOfImages: Float = 0, resolution: Float = 0)
extends Command {
  val cmd = MavCmd(2000)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = durationBetweenTwoConsecutivePictures, param2 = numberOfImages, param3 = resolution)
  override def toString = cmd.toString + " durationBetweenTwoConsecutivePictures=" + durationBetweenTwoConsecutivePictures + " numberOfImages=" + numberOfImages + " resolution=" + resolution 
}

/**
 * Stop image capture sequence
 */
case class ImageStopCapture(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Command {
  val cmd = MavCmd(2001)
  val message = CommandLong(targetSystem, targetComponent, cmd)
  override def toString = cmd.toString 
}

/**
 * Starts video capture
 * @param cameraId Camera ID (0 for all cameras), 1 for first, 2 for second, etc.
 * @param framesPerSecond Frames per second
 * @param resolution Resolution in megapixels (0.3 for 640x480, 1.3 for 1280x720, etc)
 */
case class VideoStartCapture(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, cameraId: Float = 0, framesPerSecond: Float = 0, resolution: Float = 0)
extends Command {
  val cmd = MavCmd(2500)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = cameraId, param2 = framesPerSecond, param3 = resolution)
  override def toString = cmd.toString + " cameraId=" + cameraId + " framesPerSecond=" + framesPerSecond + " resolution=" + resolution 
}

/**
 * Stop the current video capture
 */
case class VideoStopCapture(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Command {
  val cmd = MavCmd(2501)
  val message = CommandLong(targetSystem, targetComponent, cmd)
  override def toString = cmd.toString 
}

/**
 * Create a panorama at the current position
 * @param viewingAngleHorizontalOfThePanorama Viewing angle horizontal of the panorama (in degrees, +- 0.5 the total angle)
 * @param viewingAngleVerticalOfPanorama Viewing angle vertical of panorama (in degrees)
 * @param speedOfTheHorizontalRotation Speed of the horizontal rotation (in degrees per second)
 * @param speedOfTheVerticalRotation Speed of the vertical rotation (in degrees per second)
 */
case class PanoramaCreate(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, viewingAngleHorizontalOfThePanorama: Float = 0, viewingAngleVerticalOfPanorama: Float = 0, speedOfTheHorizontalRotation: Float = 0, speedOfTheVerticalRotation: Float = 0)
extends Command {
  val cmd = MavCmd(2800)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = viewingAngleHorizontalOfThePanorama, param2 = viewingAngleVerticalOfPanorama, param3 = speedOfTheHorizontalRotation, param4 = speedOfTheVerticalRotation)
  override def toString = cmd.toString + " viewingAngleHorizontalOfThePanorama=" + viewingAngleHorizontalOfThePanorama + " viewingAngleVerticalOfPanorama=" + viewingAngleVerticalOfPanorama + " speedOfTheHorizontalRotation=" + speedOfTheHorizontalRotation + " speedOfTheVerticalRotation=" + speedOfTheVerticalRotation 
}

/**
 * Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity.
 * @param operationMode Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.
 * @param desiredApproachVector Desired approach vector in degrees compass heading (0..360). A negative value indicates the system can define the approach vector at will.
 * @param desiredGroundSpeed Desired ground speed at release time. This can be overriden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.
 * @param minimumAltitudeClearance Minimum altitude clearance to the release position in meters. A negative value indicates the system can define the clearance at will.
 * @param location Latitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT / Longitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT / Altitude, in meters WGS84
 */
case class PayloadPrepareDeploy(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, operationMode: Float = 0, desiredApproachVector: Float = 0, desiredGroundSpeed: Float = 0, minimumAltitudeClearance: Float = 0, location: Coordinates = Geo())
extends Command with Location[PayloadPrepareDeploy] {
  val cmd = MavCmd(30001)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = operationMode, param2 = desiredApproachVector, param3 = desiredGroundSpeed, param4 = minimumAltitudeClearance, param5 = location.x.toFloat, param6 = location.y.toFloat, param7 = location.z.toFloat)
  def setLocation(location: Coordinates) = copy(location = location)
  override def toString = cmd.toString + " operationMode=" + operationMode + " desiredApproachVector=" + desiredApproachVector + " desiredGroundSpeed=" + desiredGroundSpeed + " minimumAltitudeClearance=" + minimumAltitudeClearance + " location=" + location 
}

object PayloadPrepareDeploy {
  def apply(loc: Coordinates): PayloadPrepareDeploy = PayloadPrepareDeploy(location = loc)
}

/**
 * Control the payload deployment.
 * @param operationMode Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deploment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.
 */
case class PayloadControlDeploy(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, operationMode: Float = 0)
extends Command {
  val cmd = MavCmd(30002)
  val message = CommandLong(targetSystem, targetComponent, cmd, param1 = operationMode)
  override def toString = cmd.toString + " operationMode=" + operationMode 
}
