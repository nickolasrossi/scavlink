// Code generated by sbt-mavgen. Manual edits will be overwritten
package scavlink.message.common

import scavlink.message._
import scavlink.message.enums._

/**
 * The heartbeat message shows that a system is present and responding. The type of the MAV and Autopilot hardware allow the receiving system to treat further messages from this system appropriate (e.g. by laying out the user interface based on the autopilot).
 * @param `type` Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)
 * @param autopilot Autopilot type / class. defined in MAV_AUTOPILOT ENUM
 * @param baseMode System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h
 * @param customMode A bitfield for use for autopilot-specific flags.
 * @param systemStatus System status flag, see MAV_STATE ENUM
 * @param mavlinkVersion MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version
 */
case class Heartbeat(`type`: Byte = 0, autopilot: Byte = 0, baseMode: Byte = 0, customMode: Int = 0, systemStatus: Byte = 0, mavlinkVersion: Byte = 0)
extends Message {
  val _id = 0
  val _name = "HEARTBEAT"
  val _bundle = Bundle.common
  override def toString = "HEARTBEAT" + " type=" + `type` + " autopilot=" + autopilot + " baseMode=" + baseMode + " customMode=" + customMode + " systemStatus=" + systemStatus + " mavlinkVersion=" + mavlinkVersion
}

/**
 * The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows wether the system is currently active or not and if an emergency occured. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occured it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.
 * @param onboardControlSensorsPresent Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
 * @param onboardControlSensorsEnabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
 * @param onboardControlSensorsHealth Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
 * @param load Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000
 * @param voltageBattery Battery voltage, in millivolts (1 = 1 millivolt)
 * @param currentBattery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
 * @param batteryRemaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery
 * @param dropRateComm Communication drops in percent, (0%: 0, 100%: 10'000), (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
 * @param errorsComm Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
 * @param errorsCount1 Autopilot-specific errors
 * @param errorsCount2 Autopilot-specific errors
 * @param errorsCount3 Autopilot-specific errors
 * @param errorsCount4 Autopilot-specific errors
 */
case class SysStatus(onboardControlSensorsPresent: Int = 0, onboardControlSensorsEnabled: Int = 0, onboardControlSensorsHealth: Int = 0, load: Short = 0, voltageBattery: Short = 0, currentBattery: Short = 0, batteryRemaining: Byte = 0, dropRateComm: Short = 0, errorsComm: Short = 0, errorsCount1: Short = 0, errorsCount2: Short = 0, errorsCount3: Short = 0, errorsCount4: Short = 0)
extends Message {
  val _id = 1
  val _name = "SYS_STATUS"
  val _bundle = Bundle.common
  override def toString = "SYS_STATUS" + " onboardControlSensorsPresent=" + onboardControlSensorsPresent + " onboardControlSensorsEnabled=" + onboardControlSensorsEnabled + " onboardControlSensorsHealth=" + onboardControlSensorsHealth + " load=" + load + " voltageBattery=" + voltageBattery + " currentBattery=" + currentBattery + " batteryRemaining=" + batteryRemaining + " dropRateComm=" + dropRateComm + " errorsComm=" + errorsComm + " errorsCount1=" + errorsCount1 + " errorsCount2=" + errorsCount2 + " errorsCount3=" + errorsCount3 + " errorsCount4=" + errorsCount4
}

/**
 * The system time is the time of the master clock, typically the computer clock of the main onboard computer.
 * @param timeUnixUsec Timestamp of the master clock in microseconds since UNIX epoch.
 * @param timeBootMs Timestamp of the component clock since boot time in milliseconds.
 */
case class SystemTime(timeUnixUsec: Long = 0, timeBootMs: Int = 0)
extends Message {
  val _id = 2
  val _name = "SYSTEM_TIME"
  val _bundle = Bundle.common
  override def toString = "SYSTEM_TIME" + " timeUnixUsec=" + timeUnixUsec + " timeBootMs=" + timeBootMs
}

/**
 * A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections.
 * @param timeUsec Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
 * @param seq PING sequence
 * @param targetSystem 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system
 * @param targetComponent 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system
 */
case class Ping(timeUsec: Long = 0, seq: Int = 0, targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Message with TargetComponent[Ping] {
  val _id = 4
  val _name = "PING"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): Ping = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): Ping = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): Ping = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "PING" + " timeUsec=" + timeUsec + " seq=" + seq + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent
}

/**
 * Request to control this MAV
 * @param targetSystem System the GCS requests control for
 * @param controlRequest 0: request control of this MAV, 1: Release control of this MAV
 * @param version 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
 * @param passkey Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and "!?,.-"
 */
case class ChangeOperatorControl(targetSystem: SystemId = 0, controlRequest: Byte = 0, version: Byte = 0, passkey: String = "")
extends Message with TargetSystem[ChangeOperatorControl] {
  require(passkey.length <= 25)
  val _id = 5
  val _name = "CHANGE_OPERATOR_CONTROL"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): ChangeOperatorControl = copy(targetSystem = systemId)
  override def toString = "CHANGE_OPERATOR_CONTROL" + " targetSystem=" + targetSystem + " controlRequest=" + controlRequest + " version=" + version + " passkey=" + passkey
}

/**
 * Accept / deny control of this MAV
 * @param gcsSystemId ID of the GCS this message
 * @param controlRequest 0: request control of this MAV, 1: Release control of this MAV
 * @param ack 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
 */
case class ChangeOperatorControlAck(gcsSystemId: Byte = 0, controlRequest: Byte = 0, ack: Byte = 0)
extends Message {
  val _id = 6
  val _name = "CHANGE_OPERATOR_CONTROL_ACK"
  val _bundle = Bundle.common
  override def toString = "CHANGE_OPERATOR_CONTROL_ACK" + " gcsSystemId=" + gcsSystemId + " controlRequest=" + controlRequest + " ack=" + ack
}

/**
 * Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety.
 * @param key key
 */
case class AuthKey(key: String = "")
extends Message {
  require(key.length <= 32)
  val _id = 7
  val _name = "AUTH_KEY"
  val _bundle = Bundle.common
  override def toString = "AUTH_KEY" + " key=" + key
}

/**
 * Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component.
 * @param targetSystem The system setting the mode
 * @param baseMode The new base mode
 * @param customMode The new autopilot-specific mode. This field can be ignored by an autopilot.
 */
case class SetMode(targetSystem: SystemId = 0, baseMode: Byte = 0, customMode: Int = 0)
extends Message with TargetSystem[SetMode] {
  val _id = 11
  val _name = "SET_MODE"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): SetMode = copy(targetSystem = systemId)
  override def toString = "SET_MODE" + " targetSystem=" + targetSystem + " baseMode=" + baseMode + " customMode=" + customMode
}

/**
 * Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also http://qgroundcontrol.org/parameter_interface for a full documentation of QGroundControl and IMU code.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param paramId Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
 * @param paramIndex Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
 */
case class ParamRequestRead(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, paramId: String = "", paramIndex: Short = 0)
extends Message with TargetComponent[ParamRequestRead] {
  require(paramId.length <= 16)
  val _id = 20
  val _name = "PARAM_REQUEST_READ"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): ParamRequestRead = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): ParamRequestRead = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): ParamRequestRead = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "PARAM_REQUEST_READ" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " paramId=" + paramId + " paramIndex=" + paramIndex
}

/**
 * Request all parameters of this component. After his request, all parameters are emitted.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 */
case class ParamRequestList(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Message with TargetComponent[ParamRequestList] {
  val _id = 21
  val _name = "PARAM_REQUEST_LIST"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): ParamRequestList = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): ParamRequestList = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): ParamRequestList = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "PARAM_REQUEST_LIST" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent
}

/**
 * Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout.
 * @param paramId Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
 * @param paramValue Onboard parameter value
 * @param paramType Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
 * @param paramCount Total number of onboard parameters
 * @param paramIndex Index of this onboard parameter
 */
case class ParamValue(paramId: String = "", paramValue: Float = 0, paramType: MavParamType.Value = MavParamType(0), paramCount: Short = 0, paramIndex: Short = 0)
extends Message {
  require(paramId.length <= 16)
  val _id = 22
  val _name = "PARAM_VALUE"
  val _bundle = Bundle.common
  override def toString = "PARAM_VALUE" + " paramId=" + paramId + " paramValue=" + paramValue + " paramType=" + paramType + " paramCount=" + paramCount + " paramIndex=" + paramIndex
}

/**
 * Set a parameter value TEMPORARILY to RAM. It will be reset to default on system reboot. Send the ACTION MAV_ACTION_STORAGE_WRITE to PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The receiving component should acknowledge the new parameter value by sending a param_value message to all communication partners. This will also ensure that multiple GCS all have an up-to-date list of all parameters. If the sending GCS did not receive a PARAM_VALUE message within its timeout time, it should re-send the PARAM_SET message.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param paramId Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
 * @param paramValue Onboard parameter value
 * @param paramType Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
 */
case class ParamSet(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, paramId: String = "", paramValue: Float = 0, paramType: MavParamType.Value = MavParamType(0))
extends Message with TargetComponent[ParamSet] {
  require(paramId.length <= 16)
  val _id = 23
  val _name = "PARAM_SET"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): ParamSet = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): ParamSet = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): ParamSet = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "PARAM_SET" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " paramId=" + paramId + " paramValue=" + paramValue + " paramType=" + paramType
}

/**
 * The global position, as returned by the Global Positioning System (GPS). This is
                NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame).
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param fixType 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
 * @param lat Latitude (WGS84), in degrees * 1E7
 * @param lon Longitude (WGS84), in degrees * 1E7
 * @param alt Altitude (WGS84), in meters * 1000 (positive for up)
 * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
 * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
 * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
 * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
 * @param satellitesVisible Number of satellites visible. If unknown, set to 255
 */
case class GpsRawInt(timeUsec: Long = 0, fixType: Byte = 0, lat: Int = 0, lon: Int = 0, alt: Int = 0, eph: Short = 0, epv: Short = 0, vel: Short = 0, cog: Short = 0, satellitesVisible: Byte = 0)
extends Message {
  val _id = 24
  val _name = "GPS_RAW_INT"
  val _bundle = Bundle.common
  override def toString = "GPS_RAW_INT" + " timeUsec=" + timeUsec + " fixType=" + fixType + " lat=" + lat + " lon=" + lon + " alt=" + alt + " eph=" + eph + " epv=" + epv + " vel=" + vel + " cog=" + cog + " satellitesVisible=" + satellitesVisible
}

/**
 * The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate. This message can contain information for up to 20 satellites.
 * @param satellitesVisible Number of satellites visible
 * @param satellitePrn Global satellite ID
 * @param satelliteUsed 0: Satellite not used, 1: used for localization
 * @param satelliteElevation Elevation (0: right on top of receiver, 90: on the horizon) of satellite
 * @param satelliteAzimuth Direction of satellite, 0: 0 deg, 255: 360 deg.
 * @param satelliteSnr Signal to noise ratio of satellite
 */
case class GpsStatus(satellitesVisible: Byte = 0, satellitePrn: Vector[Byte] = Vector.fill(20)(0), satelliteUsed: Vector[Byte] = Vector.fill(20)(0), satelliteElevation: Vector[Byte] = Vector.fill(20)(0), satelliteAzimuth: Vector[Byte] = Vector.fill(20)(0), satelliteSnr: Vector[Byte] = Vector.fill(20)(0))
extends Message {
  require(satellitePrn.length <= 20)
  require(satelliteUsed.length <= 20)
  require(satelliteElevation.length <= 20)
  require(satelliteAzimuth.length <= 20)
  require(satelliteSnr.length <= 20)
  val _id = 25
  val _name = "GPS_STATUS"
  val _bundle = Bundle.common
  override def toString = "GPS_STATUS" + " satellitesVisible=" + satellitesVisible + " satellitePrn=" + satellitePrn + " satelliteUsed=" + satelliteUsed + " satelliteElevation=" + satelliteElevation + " satelliteAzimuth=" + satelliteAzimuth + " satelliteSnr=" + satelliteSnr
}

/**
 * The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param xacc X acceleration (mg)
 * @param yacc Y acceleration (mg)
 * @param zacc Z acceleration (mg)
 * @param xgyro Angular speed around X axis (millirad /sec)
 * @param ygyro Angular speed around Y axis (millirad /sec)
 * @param zgyro Angular speed around Z axis (millirad /sec)
 * @param xmag X Magnetic field (milli tesla)
 * @param ymag Y Magnetic field (milli tesla)
 * @param zmag Z Magnetic field (milli tesla)
 */
case class ScaledImu(timeBootMs: Int = 0, xacc: Short = 0, yacc: Short = 0, zacc: Short = 0, xgyro: Short = 0, ygyro: Short = 0, zgyro: Short = 0, xmag: Short = 0, ymag: Short = 0, zmag: Short = 0)
extends Message {
  val _id = 26
  val _name = "SCALED_IMU"
  val _bundle = Bundle.common
  override def toString = "SCALED_IMU" + " timeBootMs=" + timeBootMs + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc + " xgyro=" + xgyro + " ygyro=" + ygyro + " zgyro=" + zgyro + " xmag=" + xmag + " ymag=" + ymag + " zmag=" + zmag
}

/**
 * The RAW IMU readings for the usual 9DOF sensor setup. This message should always contain the true raw values without any scaling to allow data capture and system debugging.
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param xacc X acceleration (raw)
 * @param yacc Y acceleration (raw)
 * @param zacc Z acceleration (raw)
 * @param xgyro Angular speed around X axis (raw)
 * @param ygyro Angular speed around Y axis (raw)
 * @param zgyro Angular speed around Z axis (raw)
 * @param xmag X Magnetic field (raw)
 * @param ymag Y Magnetic field (raw)
 * @param zmag Z Magnetic field (raw)
 */
case class RawImu(timeUsec: Long = 0, xacc: Short = 0, yacc: Short = 0, zacc: Short = 0, xgyro: Short = 0, ygyro: Short = 0, zgyro: Short = 0, xmag: Short = 0, ymag: Short = 0, zmag: Short = 0)
extends Message {
  val _id = 27
  val _name = "RAW_IMU"
  val _bundle = Bundle.common
  override def toString = "RAW_IMU" + " timeUsec=" + timeUsec + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc + " xgyro=" + xgyro + " ygyro=" + ygyro + " zgyro=" + zgyro + " xmag=" + xmag + " ymag=" + ymag + " zmag=" + zmag
}

/**
 * The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values.
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param pressAbs Absolute pressure (raw)
 * @param pressDiff1 Differential pressure 1 (raw)
 * @param pressDiff2 Differential pressure 2 (raw)
 * @param temperature Raw Temperature measurement (raw)
 */
case class RawPressure(timeUsec: Long = 0, pressAbs: Short = 0, pressDiff1: Short = 0, pressDiff2: Short = 0, temperature: Short = 0)
extends Message {
  val _id = 28
  val _name = "RAW_PRESSURE"
  val _bundle = Bundle.common
  override def toString = "RAW_PRESSURE" + " timeUsec=" + timeUsec + " pressAbs=" + pressAbs + " pressDiff1=" + pressDiff1 + " pressDiff2=" + pressDiff2 + " temperature=" + temperature
}

/**
 * The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param pressAbs Absolute pressure (hectopascal)
 * @param pressDiff Differential pressure 1 (hectopascal)
 * @param temperature Temperature measurement (0.01 degrees celsius)
 */
case class ScaledPressure(timeBootMs: Int = 0, pressAbs: Float = 0, pressDiff: Float = 0, temperature: Short = 0)
extends Message {
  val _id = 29
  val _name = "SCALED_PRESSURE"
  val _bundle = Bundle.common
  override def toString = "SCALED_PRESSURE" + " timeBootMs=" + timeBootMs + " pressAbs=" + pressAbs + " pressDiff=" + pressDiff + " temperature=" + temperature
}

/**
 * The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right).
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param roll Roll angle (rad, -pi..+pi)
 * @param pitch Pitch angle (rad, -pi..+pi)
 * @param yaw Yaw angle (rad, -pi..+pi)
 * @param rollspeed Roll angular speed (rad/s)
 * @param pitchspeed Pitch angular speed (rad/s)
 * @param yawspeed Yaw angular speed (rad/s)
 */
case class Attitude(timeBootMs: Int = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, rollspeed: Float = 0, pitchspeed: Float = 0, yawspeed: Float = 0)
extends Message {
  val _id = 30
  val _name = "ATTITUDE"
  val _bundle = Bundle.common
  override def toString = "ATTITUDE" + " timeBootMs=" + timeBootMs + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " rollspeed=" + rollspeed + " pitchspeed=" + pitchspeed + " yawspeed=" + yawspeed
}

/**
 * The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param q1 Quaternion component 1, w (1 in null-rotation)
 * @param q2 Quaternion component 2, x (0 in null-rotation)
 * @param q3 Quaternion component 3, y (0 in null-rotation)
 * @param q4 Quaternion component 4, z (0 in null-rotation)
 * @param rollspeed Roll angular speed (rad/s)
 * @param pitchspeed Pitch angular speed (rad/s)
 * @param yawspeed Yaw angular speed (rad/s)
 */
case class AttitudeQuaternion(timeBootMs: Int = 0, q1: Float = 0, q2: Float = 0, q3: Float = 0, q4: Float = 0, rollspeed: Float = 0, pitchspeed: Float = 0, yawspeed: Float = 0)
extends Message {
  val _id = 31
  val _name = "ATTITUDE_QUATERNION"
  val _bundle = Bundle.common
  override def toString = "ATTITUDE_QUATERNION" + " timeBootMs=" + timeBootMs + " q1=" + q1 + " q2=" + q2 + " q3=" + q3 + " q4=" + q4 + " rollspeed=" + rollspeed + " pitchspeed=" + pitchspeed + " yawspeed=" + yawspeed
}

/**
 * The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param x X Position
 * @param y Y Position
 * @param z Z Position
 * @param vx X Speed
 * @param vy Y Speed
 * @param vz Z Speed
 */
case class LocalPositionNed(timeBootMs: Int = 0, x: Float = 0, y: Float = 0, z: Float = 0, vx: Float = 0, vy: Float = 0, vz: Float = 0)
extends Message {
  val _id = 32
  val _name = "LOCAL_POSITION_NED"
  val _bundle = Bundle.common
  override def toString = "LOCAL_POSITION_NED" + " timeBootMs=" + timeBootMs + " x=" + x + " y=" + y + " z=" + z + " vx=" + vx + " vy=" + vy + " vz=" + vz
}

/**
 * The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It
               is designed as scaled integer message since the resolution of float is not sufficient.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param lat Latitude, expressed as * 1E7
 * @param lon Longitude, expressed as * 1E7
 * @param alt Altitude in meters, expressed as * 1000 (millimeters), WGS84 (not AMSL)
 * @param relativeAlt Altitude above ground in meters, expressed as * 1000 (millimeters)
 * @param vx Ground X Speed (Latitude), expressed as m/s * 100
 * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
 * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
 * @param hdg Compass heading in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
 */
case class GlobalPositionInt(timeBootMs: Int = 0, lat: Int = 0, lon: Int = 0, alt: Int = 0, relativeAlt: Int = 0, vx: Short = 0, vy: Short = 0, vz: Short = 0, hdg: Short = 0)
extends Message {
  val _id = 33
  val _name = "GLOBAL_POSITION_INT"
  val _bundle = Bundle.common
  override def toString = "GLOBAL_POSITION_INT" + " timeBootMs=" + timeBootMs + " lat=" + lat + " lon=" + lon + " alt=" + alt + " relativeAlt=" + relativeAlt + " vx=" + vx + " vy=" + vy + " vz=" + vz + " hdg=" + hdg
}

/**
 * The scaled values of the RC channels received. (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to UINT16_MAX.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
 * @param chan1Scaled RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param chan2Scaled RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param chan3Scaled RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param chan4Scaled RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param chan5Scaled RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param chan6Scaled RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param chan7Scaled RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param chan8Scaled RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
 * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
 */
case class RcChannelsScaled(timeBootMs: Int = 0, port: Byte = 0, chan1Scaled: Short = 0, chan2Scaled: Short = 0, chan3Scaled: Short = 0, chan4Scaled: Short = 0, chan5Scaled: Short = 0, chan6Scaled: Short = 0, chan7Scaled: Short = 0, chan8Scaled: Short = 0, rssi: Byte = 0)
extends Message {
  val _id = 34
  val _name = "RC_CHANNELS_SCALED"
  val _bundle = Bundle.common
  override def toString = "RC_CHANNELS_SCALED" + " timeBootMs=" + timeBootMs + " port=" + port + " chan1Scaled=" + chan1Scaled + " chan2Scaled=" + chan2Scaled + " chan3Scaled=" + chan3Scaled + " chan4Scaled=" + chan4Scaled + " chan5Scaled=" + chan5Scaled + " chan6Scaled=" + chan6Scaled + " chan7Scaled=" + chan7Scaled + " chan8Scaled=" + chan8Scaled + " rssi=" + rssi
}

/**
 * The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
 * @param chan1Raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan2Raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan3Raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan4Raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan5Raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan6Raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan7Raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan8Raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
 */
case class RcChannelsRaw(timeBootMs: Int = 0, port: Byte = 0, chan1Raw: Short = 0, chan2Raw: Short = 0, chan3Raw: Short = 0, chan4Raw: Short = 0, chan5Raw: Short = 0, chan6Raw: Short = 0, chan7Raw: Short = 0, chan8Raw: Short = 0, rssi: Byte = 0)
extends Message {
  val _id = 35
  val _name = "RC_CHANNELS_RAW"
  val _bundle = Bundle.common
  override def toString = "RC_CHANNELS_RAW" + " timeBootMs=" + timeBootMs + " port=" + port + " chan1Raw=" + chan1Raw + " chan2Raw=" + chan2Raw + " chan3Raw=" + chan3Raw + " chan4Raw=" + chan4Raw + " chan5Raw=" + chan5Raw + " chan6Raw=" + chan6Raw + " chan7Raw=" + chan7Raw + " chan8Raw=" + chan8Raw + " rssi=" + rssi
}

/**
 * The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.
 * @param timeUsec Timestamp (microseconds since system boot)
 * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
 * @param servo1Raw Servo output 1 value, in microseconds
 * @param servo2Raw Servo output 2 value, in microseconds
 * @param servo3Raw Servo output 3 value, in microseconds
 * @param servo4Raw Servo output 4 value, in microseconds
 * @param servo5Raw Servo output 5 value, in microseconds
 * @param servo6Raw Servo output 6 value, in microseconds
 * @param servo7Raw Servo output 7 value, in microseconds
 * @param servo8Raw Servo output 8 value, in microseconds
 */
case class ServoOutputRaw(timeUsec: Int = 0, port: Byte = 0, servo1Raw: Short = 0, servo2Raw: Short = 0, servo3Raw: Short = 0, servo4Raw: Short = 0, servo5Raw: Short = 0, servo6Raw: Short = 0, servo7Raw: Short = 0, servo8Raw: Short = 0)
extends Message {
  val _id = 36
  val _name = "SERVO_OUTPUT_RAW"
  val _bundle = Bundle.common
  override def toString = "SERVO_OUTPUT_RAW" + " timeUsec=" + timeUsec + " port=" + port + " servo1Raw=" + servo1Raw + " servo2Raw=" + servo2Raw + " servo3Raw=" + servo3Raw + " servo4Raw=" + servo4Raw + " servo5Raw=" + servo5Raw + " servo6Raw=" + servo6Raw + " servo7Raw=" + servo7Raw + " servo8Raw=" + servo8Raw
}

/**
 * Request a partial list of mission items from the system/component. http://qgroundcontrol.org/mavlink/waypoint_protocol. If start and end index are the same, just send one waypoint.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param startIndex Start index, 0 by default
 * @param endIndex End index, -1 by default (-1: send list to end). Else a valid index of the list
 */
case class MissionRequestPartialList(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, startIndex: Short = 0, endIndex: Short = 0)
extends Message with TargetComponent[MissionRequestPartialList] {
  val _id = 37
  val _name = "MISSION_REQUEST_PARTIAL_LIST"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionRequestPartialList = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionRequestPartialList = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionRequestPartialList = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_REQUEST_PARTIAL_LIST" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " startIndex=" + startIndex + " endIndex=" + endIndex
}

/**
 * This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param startIndex Start index, 0 by default and smaller / equal to the largest index of the current onboard list.
 * @param endIndex End index, equal or greater than start index.
 */
case class MissionWritePartialList(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, startIndex: Short = 0, endIndex: Short = 0)
extends Message with TargetComponent[MissionWritePartialList] {
  val _id = 38
  val _name = "MISSION_WRITE_PARTIAL_LIST"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionWritePartialList = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionWritePartialList = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionWritePartialList = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_WRITE_PARTIAL_LIST" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " startIndex=" + startIndex + " endIndex=" + endIndex
}

/**
 * Message encoding a mission item. This message is emitted to announce
                the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See also http://qgroundcontrol.org/mavlink/waypoint_protocol.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param seq Sequence
 * @param frame The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
 * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
 * @param current false:0, true:1
 * @param autocontinue autocontinue to next wp
 * @param param1 PARAM1, see MAV_CMD enum
 * @param param2 PARAM2, see MAV_CMD enum
 * @param param3 PARAM3, see MAV_CMD enum
 * @param param4 PARAM4, see MAV_CMD enum
 * @param x PARAM5 / local: x position, global: latitude
 * @param y PARAM6 / y position: global: longitude
 * @param z PARAM7 / z position: global: altitude (relative or absolute, depending on frame.
 */
case class MissionItem(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, seq: Short = 0, frame: Byte = 0, command: Short = 0, current: Byte = 0, autocontinue: Byte = 0, param1: Float = 0, param2: Float = 0, param3: Float = 0, param4: Float = 0, x: Float = 0, y: Float = 0, z: Float = 0)
extends Message with TargetComponent[MissionItem] {
  val _id = 39
  val _name = "MISSION_ITEM"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionItem = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionItem = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionItem = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_ITEM" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " seq=" + seq + " frame=" + frame + " command=" + command + " current=" + current + " autocontinue=" + autocontinue + " param1=" + param1 + " param2=" + param2 + " param3=" + param3 + " param4=" + param4 + " x=" + x + " y=" + y + " z=" + z
}

/**
 * Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. http://qgroundcontrol.org/mavlink/waypoint_protocol
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param seq Sequence
 */
case class MissionRequest(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, seq: Short = 0)
extends Message with TargetComponent[MissionRequest] {
  val _id = 40
  val _name = "MISSION_REQUEST"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionRequest = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionRequest = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionRequest = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_REQUEST" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " seq=" + seq
}

/**
 * Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between).
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param seq Sequence
 */
case class MissionSetCurrent(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, seq: Short = 0)
extends Message with TargetComponent[MissionSetCurrent] {
  val _id = 41
  val _name = "MISSION_SET_CURRENT"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionSetCurrent = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionSetCurrent = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionSetCurrent = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_SET_CURRENT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " seq=" + seq
}

/**
 * Message that announces the sequence number of the current active mission item. The MAV will fly towards this mission item.
 * @param seq Sequence
 */
case class MissionCurrent(seq: Short = 0)
extends Message {
  val _id = 42
  val _name = "MISSION_CURRENT"
  val _bundle = Bundle.common
  override def toString = "MISSION_CURRENT" + " seq=" + seq
}

/**
 * Request the overall list of mission items from the system/component.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 */
case class MissionRequestList(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Message with TargetComponent[MissionRequestList] {
  val _id = 43
  val _name = "MISSION_REQUEST_LIST"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionRequestList = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionRequestList = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionRequestList = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_REQUEST_LIST" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent
}

/**
 * This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of MISSIONs.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param count Number of mission items in the sequence
 */
case class MissionCount(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, count: Short = 0)
extends Message with TargetComponent[MissionCount] {
  val _id = 44
  val _name = "MISSION_COUNT"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionCount = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionCount = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionCount = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_COUNT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " count=" + count
}

/**
 * Delete all mission items at once.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 */
case class MissionClearAll(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Message with TargetComponent[MissionClearAll] {
  val _id = 45
  val _name = "MISSION_CLEAR_ALL"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionClearAll = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionClearAll = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionClearAll = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_CLEAR_ALL" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent
}

/**
 * A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next MISSION.
 * @param seq Sequence
 */
case class MissionItemReached(seq: Short = 0)
extends Message {
  val _id = 46
  val _name = "MISSION_ITEM_REACHED"
  val _bundle = Bundle.common
  override def toString = "MISSION_ITEM_REACHED" + " seq=" + seq
}

/**
 * Ack message during MISSION handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero).
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param `type` See MAV_MISSION_RESULT enum
 */
case class MissionAck(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, `type`: MavMissionResult.Value = MavMissionResult(0))
extends Message with TargetComponent[MissionAck] {
  val _id = 47
  val _name = "MISSION_ACK"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionAck = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionAck = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionAck = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_ACK" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " type=" + `type`
}

/**
 * As local waypoints exist, the global MISSION reference allows to transform between the local coordinate frame and the global (GPS) coordinate frame. This can be necessary when e.g. in- and outdoor settings are connected and the MAV should move from in- to outdoor.
 * @param targetSystem System ID
 * @param latitude Latitude (WGS84), in degrees * 1E7
 * @param longitude Longitude (WGS84, in degrees * 1E7
 * @param altitude Altitude (WGS84), in meters * 1000 (positive for up)
 */
case class SetGpsGlobalOrigin(targetSystem: SystemId = 0, latitude: Int = 0, longitude: Int = 0, altitude: Int = 0)
extends Message with TargetSystem[SetGpsGlobalOrigin] {
  val _id = 48
  val _name = "SET_GPS_GLOBAL_ORIGIN"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): SetGpsGlobalOrigin = copy(targetSystem = systemId)
  override def toString = "SET_GPS_GLOBAL_ORIGIN" + " targetSystem=" + targetSystem + " latitude=" + latitude + " longitude=" + longitude + " altitude=" + altitude
}

/**
 * Once the MAV sets a new GPS-Local correspondence, this message announces the origin (0,0,0) position
 * @param latitude Latitude (WGS84), in degrees * 1E7
 * @param longitude Longitude (WGS84), in degrees * 1E7
 * @param altitude Altitude (WGS84), in meters * 1000 (positive for up)
 */
case class GpsGlobalOrigin(latitude: Int = 0, longitude: Int = 0, altitude: Int = 0)
extends Message {
  val _id = 49
  val _name = "GPS_GLOBAL_ORIGIN"
  val _bundle = Bundle.common
  override def toString = "GPS_GLOBAL_ORIGIN" + " latitude=" + latitude + " longitude=" + longitude + " altitude=" + altitude
}

/**
 * Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/MISSIONs to accept and which to reject. Safety areas are often enforced by national or competition regulations.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param frame Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
 * @param p1x x position 1 / Latitude 1
 * @param p1y y position 1 / Longitude 1
 * @param p1z z position 1 / Altitude 1
 * @param p2x x position 2 / Latitude 2
 * @param p2y y position 2 / Longitude 2
 * @param p2z z position 2 / Altitude 2
 */
case class SafetySetAllowedArea(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, frame: MavFrame.Value = MavFrame(0), p1x: Float = 0, p1y: Float = 0, p1z: Float = 0, p2x: Float = 0, p2y: Float = 0, p2z: Float = 0)
extends Message with TargetComponent[SafetySetAllowedArea] {
  val _id = 54
  val _name = "SAFETY_SET_ALLOWED_AREA"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): SafetySetAllowedArea = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): SafetySetAllowedArea = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): SafetySetAllowedArea = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "SAFETY_SET_ALLOWED_AREA" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " frame=" + frame + " p1x=" + p1x + " p1y=" + p1y + " p1z=" + p1z + " p2x=" + p2x + " p2y=" + p2y + " p2z=" + p2z
}

/**
 * Read out the safety zone the MAV currently assumes.
 * @param frame Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
 * @param p1x x position 1 / Latitude 1
 * @param p1y y position 1 / Longitude 1
 * @param p1z z position 1 / Altitude 1
 * @param p2x x position 2 / Latitude 2
 * @param p2y y position 2 / Longitude 2
 * @param p2z z position 2 / Altitude 2
 */
case class SafetyAllowedArea(frame: MavFrame.Value = MavFrame(0), p1x: Float = 0, p1y: Float = 0, p1z: Float = 0, p2x: Float = 0, p2y: Float = 0, p2z: Float = 0)
extends Message {
  val _id = 55
  val _name = "SAFETY_ALLOWED_AREA"
  val _bundle = Bundle.common
  override def toString = "SAFETY_ALLOWED_AREA" + " frame=" + frame + " p1x=" + p1x + " p1y=" + p1y + " p1z=" + p1z + " p2x=" + p2x + " p2y=" + p2y + " p2z=" + p2z
}

/**
 * The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param q Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
 * @param rollspeed Roll angular speed (rad/s)
 * @param pitchspeed Pitch angular speed (rad/s)
 * @param yawspeed Yaw angular speed (rad/s)
 * @param covariance Attitude covariance
 */
case class AttitudeQuaternionCov(timeBootMs: Int = 0, q: (Float,Float,Float,Float) = (0,0,0,0), rollspeed: Float = 0, pitchspeed: Float = 0, yawspeed: Float = 0, covariance: Vector[Float] = Vector.fill(9)(0))
extends Message {
  require(covariance.length <= 9)
  val _id = 61
  val _name = "ATTITUDE_QUATERNION_COV"
  val _bundle = Bundle.common
  override def toString = "ATTITUDE_QUATERNION_COV" + " timeBootMs=" + timeBootMs + " q=" + q + " rollspeed=" + rollspeed + " pitchspeed=" + pitchspeed + " yawspeed=" + yawspeed + " covariance=" + covariance
}

/**
 * Outputs of the APM navigation controller. The primary use of this message is to check the response and signs of the controller before actual flight and to assist with tuning controller parameters.
 * @param navRoll Current desired roll in degrees
 * @param navPitch Current desired pitch in degrees
 * @param navBearing Current desired heading in degrees
 * @param targetBearing Bearing to current MISSION/target in degrees
 * @param wpDist Distance to active MISSION in meters
 * @param altError Current altitude error in meters
 * @param aspdError Current airspeed error in meters/second
 * @param xtrackError Current crosstrack error on x-y plane in meters
 */
case class NavControllerOutput(navRoll: Float = 0, navPitch: Float = 0, navBearing: Short = 0, targetBearing: Short = 0, wpDist: Short = 0, altError: Float = 0, aspdError: Float = 0, xtrackError: Float = 0)
extends Message {
  val _id = 62
  val _name = "NAV_CONTROLLER_OUTPUT"
  val _bundle = Bundle.common
  override def toString = "NAV_CONTROLLER_OUTPUT" + " navRoll=" + navRoll + " navPitch=" + navPitch + " navBearing=" + navBearing + " targetBearing=" + targetBearing + " wpDist=" + wpDist + " altError=" + altError + " aspdError=" + aspdError + " xtrackError=" + xtrackError
}

/**
 * The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param timeUtc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
 * @param estimatorType Class id of the estimator this estimate originated from.
 * @param lat Latitude, expressed as degrees * 1E7
 * @param lon Longitude, expressed as degrees * 1E7
 * @param alt Altitude in meters, expressed as * 1000 (millimeters), above MSL
 * @param relativeAlt Altitude above ground in meters, expressed as * 1000 (millimeters)
 * @param vx Ground X Speed (Latitude), expressed as m/s
 * @param vy Ground Y Speed (Longitude), expressed as m/s
 * @param vz Ground Z Speed (Altitude), expressed as m/s
 * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
 */
case class GlobalPositionIntCov(timeBootMs: Int = 0, timeUtc: Long = 0, estimatorType: MavEstimatorType.Value = MavEstimatorType(0), lat: Int = 0, lon: Int = 0, alt: Int = 0, relativeAlt: Int = 0, vx: Float = 0, vy: Float = 0, vz: Float = 0, covariance: Vector[Float] = Vector.fill(36)(0))
extends Message {
  require(covariance.length <= 36)
  val _id = 63
  val _name = "GLOBAL_POSITION_INT_COV"
  val _bundle = Bundle.common
  override def toString = "GLOBAL_POSITION_INT_COV" + " timeBootMs=" + timeBootMs + " timeUtc=" + timeUtc + " estimatorType=" + estimatorType + " lat=" + lat + " lon=" + lon + " alt=" + alt + " relativeAlt=" + relativeAlt + " vx=" + vx + " vy=" + vy + " vz=" + vz + " covariance=" + covariance
}

/**
 * The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param timeUtc Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
 * @param estimatorType Class id of the estimator this estimate originated from.
 * @param x X Position
 * @param y Y Position
 * @param z Z Position
 * @param vx X Speed
 * @param vy Y Speed
 * @param vz Z Speed
 * @param covariance Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
 */
case class LocalPositionNedCov(timeBootMs: Int = 0, timeUtc: Long = 0, estimatorType: MavEstimatorType.Value = MavEstimatorType(0), x: Float = 0, y: Float = 0, z: Float = 0, vx: Float = 0, vy: Float = 0, vz: Float = 0, covariance: Vector[Float] = Vector.fill(36)(0))
extends Message {
  require(covariance.length <= 36)
  val _id = 64
  val _name = "LOCAL_POSITION_NED_COV"
  val _bundle = Bundle.common
  override def toString = "LOCAL_POSITION_NED_COV" + " timeBootMs=" + timeBootMs + " timeUtc=" + timeUtc + " estimatorType=" + estimatorType + " x=" + x + " y=" + y + " z=" + z + " vx=" + vx + " vy=" + vy + " vz=" + vz + " covariance=" + covariance
}

/**
 * The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param chancount Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
 * @param chan1Raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan2Raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan3Raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan4Raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan5Raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan6Raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan7Raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan8Raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan9Raw RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan10Raw RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan11Raw RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan12Raw RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan13Raw RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan14Raw RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan15Raw RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan16Raw RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan17Raw RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan18Raw RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
 */
case class RcChannels(timeBootMs: Int = 0, chancount: Byte = 0, chan1Raw: Short = 0, chan2Raw: Short = 0, chan3Raw: Short = 0, chan4Raw: Short = 0, chan5Raw: Short = 0, chan6Raw: Short = 0, chan7Raw: Short = 0, chan8Raw: Short = 0, chan9Raw: Short = 0, chan10Raw: Short = 0, chan11Raw: Short = 0, chan12Raw: Short = 0, chan13Raw: Short = 0, chan14Raw: Short = 0, chan15Raw: Short = 0, chan16Raw: Short = 0, chan17Raw: Short = 0, chan18Raw: Short = 0, rssi: Byte = 0)
extends Message {
  val _id = 65
  val _name = "RC_CHANNELS"
  val _bundle = Bundle.common
  override def toString = "RC_CHANNELS" + " timeBootMs=" + timeBootMs + " chancount=" + chancount + " chan1Raw=" + chan1Raw + " chan2Raw=" + chan2Raw + " chan3Raw=" + chan3Raw + " chan4Raw=" + chan4Raw + " chan5Raw=" + chan5Raw + " chan6Raw=" + chan6Raw + " chan7Raw=" + chan7Raw + " chan8Raw=" + chan8Raw + " chan9Raw=" + chan9Raw + " chan10Raw=" + chan10Raw + " chan11Raw=" + chan11Raw + " chan12Raw=" + chan12Raw + " chan13Raw=" + chan13Raw + " chan14Raw=" + chan14Raw + " chan15Raw=" + chan15Raw + " chan16Raw=" + chan16Raw + " chan17Raw=" + chan17Raw + " chan18Raw=" + chan18Raw + " rssi=" + rssi
}

/**
 * @param targetSystem The target requested to send the message stream.
 * @param targetComponent The target requested to send the message stream.
 * @param reqStreamId The ID of the requested data stream
 * @param reqMessageRate The requested interval between two messages of this type
 * @param startStop 1 to start sending, 0 to stop sending.
 */
case class RequestDataStream(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, reqStreamId: Byte = 0, reqMessageRate: Short = 0, startStop: Byte = 0)
extends Message with TargetComponent[RequestDataStream] {
  val _id = 66
  val _name = "REQUEST_DATA_STREAM"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): RequestDataStream = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): RequestDataStream = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): RequestDataStream = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "REQUEST_DATA_STREAM" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " reqStreamId=" + reqStreamId + " reqMessageRate=" + reqMessageRate + " startStop=" + startStop
}

/**
 * @param streamId The ID of the requested data stream
 * @param messageRate The requested interval between two messages of this type
 * @param onOff 1 stream is enabled, 0 stream is stopped.
 */
case class DataStream(streamId: Byte = 0, messageRate: Short = 0, onOff: Byte = 0)
extends Message {
  val _id = 67
  val _name = "DATA_STREAM"
  val _bundle = Bundle.common
  override def toString = "DATA_STREAM" + " streamId=" + streamId + " messageRate=" + messageRate + " onOff=" + onOff
}

/**
 * This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled an buttons are also transmit as boolean values of their
 * @param targetSystem The system to be controlled.
 * @param x X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
 * @param y Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
 * @param z Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle.
 * @param r R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
 * @param buttons A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
 */
case class ManualControl(targetSystem: SystemId = 0, x: Short = 0, y: Short = 0, z: Short = 0, r: Short = 0, buttons: Short = 0)
extends Message with TargetSystem[ManualControl] {
  val _id = 69
  val _name = "MANUAL_CONTROL"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): ManualControl = copy(targetSystem = systemId)
  override def toString = "MANUAL_CONTROL" + " targetSystem=" + targetSystem + " x=" + x + " y=" + y + " z=" + z + " r=" + r + " buttons=" + buttons
}

/**
 * The RAW values of the RC channels sent to the MAV to override info received from the RC radio. A value of UINT16_MAX means no change to that channel. A value of 0 means control of that channel should be released back to the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param chan1Raw RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 * @param chan2Raw RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 * @param chan3Raw RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 * @param chan4Raw RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 * @param chan5Raw RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 * @param chan6Raw RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 * @param chan7Raw RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 * @param chan8Raw RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.
 */
case class RcChannelsOverride(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, chan1Raw: Short = 0, chan2Raw: Short = 0, chan3Raw: Short = 0, chan4Raw: Short = 0, chan5Raw: Short = 0, chan6Raw: Short = 0, chan7Raw: Short = 0, chan8Raw: Short = 0)
extends Message with TargetComponent[RcChannelsOverride] {
  val _id = 70
  val _name = "RC_CHANNELS_OVERRIDE"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): RcChannelsOverride = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): RcChannelsOverride = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): RcChannelsOverride = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "RC_CHANNELS_OVERRIDE" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " chan1Raw=" + chan1Raw + " chan2Raw=" + chan2Raw + " chan3Raw=" + chan3Raw + " chan4Raw=" + chan4Raw + " chan5Raw=" + chan5Raw + " chan6Raw=" + chan6Raw + " chan7Raw=" + chan7Raw + " chan8Raw=" + chan8Raw
}

/**
 * Message encoding a mission item. This message is emitted to announce
                the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See alsohttp://qgroundcontrol.org/mavlink/waypoint_protocol.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param seq Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
 * @param frame The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
 * @param command The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
 * @param current false:0, true:1
 * @param autocontinue autocontinue to next wp
 * @param param1 PARAM1, see MAV_CMD enum
 * @param param2 PARAM2, see MAV_CMD enum
 * @param param3 PARAM3, see MAV_CMD enum
 * @param param4 PARAM4, see MAV_CMD enum
 * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
 * @param y PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
 * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
 */
case class MissionItemInt(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, seq: Short = 0, frame: Byte = 0, command: Short = 0, current: Byte = 0, autocontinue: Byte = 0, param1: Float = 0, param2: Float = 0, param3: Float = 0, param4: Float = 0, x: Int = 0, y: Int = 0, z: Float = 0)
extends Message with TargetComponent[MissionItemInt] {
  val _id = 73
  val _name = "MISSION_ITEM_INT"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): MissionItemInt = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MissionItemInt = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MissionItemInt = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MISSION_ITEM_INT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " seq=" + seq + " frame=" + frame + " command=" + command + " current=" + current + " autocontinue=" + autocontinue + " param1=" + param1 + " param2=" + param2 + " param3=" + param3 + " param4=" + param4 + " x=" + x + " y=" + y + " z=" + z
}

/**
 * Metrics typically displayed on a HUD for fixed wing aircraft
 * @param airspeed Current airspeed in m/s
 * @param groundspeed Current ground speed in m/s
 * @param heading Current heading in degrees, in compass units (0..360, 0=north)
 * @param throttle Current throttle setting in integer percent, 0 to 100
 * @param alt Current altitude (MSL), in meters
 * @param climb Current climb rate in meters/second
 */
case class VfrHud(airspeed: Float = 0, groundspeed: Float = 0, heading: Short = 0, throttle: Short = 0, alt: Float = 0, climb: Float = 0)
extends Message {
  val _id = 74
  val _name = "VFR_HUD"
  val _bundle = Bundle.common
  override def toString = "VFR_HUD" + " airspeed=" + airspeed + " groundspeed=" + groundspeed + " heading=" + heading + " throttle=" + throttle + " alt=" + alt + " climb=" + climb
}

/**
 * Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param frame The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h
 * @param command The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs
 * @param current false:0, true:1
 * @param autocontinue autocontinue to next wp
 * @param param1 PARAM1, see MAV_CMD enum
 * @param param2 PARAM2, see MAV_CMD enum
 * @param param3 PARAM3, see MAV_CMD enum
 * @param param4 PARAM4, see MAV_CMD enum
 * @param x PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
 * @param y PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
 * @param z PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
 */
case class CommandInt(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, frame: Byte = 0, command: Short = 0, current: Byte = 0, autocontinue: Byte = 0, param1: Float = 0, param2: Float = 0, param3: Float = 0, param4: Float = 0, x: Int = 0, y: Int = 0, z: Float = 0)
extends Message with TargetComponent[CommandInt] {
  val _id = 75
  val _name = "COMMAND_INT"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): CommandInt = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): CommandInt = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): CommandInt = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "COMMAND_INT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " frame=" + frame + " command=" + command + " current=" + current + " autocontinue=" + autocontinue + " param1=" + param1 + " param2=" + param2 + " param3=" + param3 + " param4=" + param4 + " x=" + x + " y=" + y + " z=" + z
}

/**
 * Send a command with up to seven parameters to the MAV
 * @param targetSystem System which should execute the command
 * @param targetComponent Component which should execute the command, 0 for all components
 * @param command Command ID, as defined by MAV_CMD enum.
 * @param confirmation 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
 * @param param1 Parameter 1, as defined by MAV_CMD enum.
 * @param param2 Parameter 2, as defined by MAV_CMD enum.
 * @param param3 Parameter 3, as defined by MAV_CMD enum.
 * @param param4 Parameter 4, as defined by MAV_CMD enum.
 * @param param5 Parameter 5, as defined by MAV_CMD enum.
 * @param param6 Parameter 6, as defined by MAV_CMD enum.
 * @param param7 Parameter 7, as defined by MAV_CMD enum.
 */
case class CommandLong(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, command: MavCmd.Value = MavCmd(0), confirmation: Byte = 0, param1: Float = 0, param2: Float = 0, param3: Float = 0, param4: Float = 0, param5: Float = 0, param6: Float = 0, param7: Float = 0)
extends Message with TargetComponent[CommandLong] {
  val _id = 76
  val _name = "COMMAND_LONG"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): CommandLong = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): CommandLong = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): CommandLong = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "COMMAND_LONG" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " command=" + command + " confirmation=" + confirmation + " param1=" + param1 + " param2=" + param2 + " param3=" + param3 + " param4=" + param4 + " param5=" + param5 + " param6=" + param6 + " param7=" + param7
}

/**
 * Report status of a command. Includes feedback wether the command was executed.
 * @param command Command ID, as defined by MAV_CMD enum.
 * @param result See MAV_RESULT enum
 */
case class CommandAck(command: MavCmd.Value = MavCmd(0), result: Byte = 0)
extends Message {
  val _id = 77
  val _name = "COMMAND_ACK"
  val _bundle = Bundle.common
  override def toString = "COMMAND_ACK" + " command=" + command + " result=" + result
}

/**
 * Setpoint in roll, pitch, yaw and thrust from the operator
 * @param timeBootMs Timestamp in milliseconds since system boot
 * @param roll Desired roll rate in radians per second
 * @param pitch Desired pitch rate in radians per second
 * @param yaw Desired yaw rate in radians per second
 * @param thrust Collective thrust, normalized to 0 .. 1
 * @param modeSwitch Flight mode switch position, 0.. 255
 * @param manualOverrideSwitch Override mode switch position, 0.. 255
 */
case class ManualSetpoint(timeBootMs: Int = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, thrust: Float = 0, modeSwitch: Byte = 0, manualOverrideSwitch: Byte = 0)
extends Message {
  val _id = 81
  val _name = "MANUAL_SETPOINT"
  val _bundle = Bundle.common
  override def toString = "MANUAL_SETPOINT" + " timeBootMs=" + timeBootMs + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " thrust=" + thrust + " modeSwitch=" + modeSwitch + " manualOverrideSwitch=" + manualOverrideSwitch
}

/**
 * Set the vehicle attitude and body angular rates.
 * @param timeBootMs Timestamp in milliseconds since system boot
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param typeMask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
 * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
 * @param bodyRollRate Body roll rate in radians per second
 * @param bodyPitchRate Body roll rate in radians per second
 * @param bodyYawRate Body roll rate in radians per second
 * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
 */
case class SetAttitudeTarget(timeBootMs: Int = 0, targetSystem: SystemId = 0, targetComponent: ComponentId = 0, typeMask: Byte = 0, q: (Float,Float,Float,Float) = (0,0,0,0), bodyRollRate: Float = 0, bodyPitchRate: Float = 0, bodyYawRate: Float = 0, thrust: Float = 0)
extends Message with TargetComponent[SetAttitudeTarget] {
  val _id = 82
  val _name = "SET_ATTITUDE_TARGET"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): SetAttitudeTarget = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): SetAttitudeTarget = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): SetAttitudeTarget = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "SET_ATTITUDE_TARGET" + " timeBootMs=" + timeBootMs + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " typeMask=" + typeMask + " q=" + q + " bodyRollRate=" + bodyRollRate + " bodyPitchRate=" + bodyPitchRate + " bodyYawRate=" + bodyYawRate + " thrust=" + thrust
}

/**
 * Set the vehicle attitude and body angular rates.
 * @param timeBootMs Timestamp in milliseconds since system boot
 * @param typeMask Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
 * @param q Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
 * @param bodyRollRate Body roll rate in radians per second
 * @param bodyPitchRate Body roll rate in radians per second
 * @param bodyYawRate Body roll rate in radians per second
 * @param thrust Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
 */
case class AttitudeTarget(timeBootMs: Int = 0, typeMask: Byte = 0, q: (Float,Float,Float,Float) = (0,0,0,0), bodyRollRate: Float = 0, bodyPitchRate: Float = 0, bodyYawRate: Float = 0, thrust: Float = 0)
extends Message {
  val _id = 83
  val _name = "ATTITUDE_TARGET"
  val _bundle = Bundle.common
  override def toString = "ATTITUDE_TARGET" + " timeBootMs=" + timeBootMs + " typeMask=" + typeMask + " q=" + q + " bodyRollRate=" + bodyRollRate + " bodyPitchRate=" + bodyPitchRate + " bodyYawRate=" + bodyYawRate + " thrust=" + thrust
}

/**
 * Set vehicle position, velocity and acceleration setpoint in local frame.
 * @param timeBootMs Timestamp in milliseconds since system boot
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param coordinateFrame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
 * @param typeMask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
 * @param x X Position in NED frame in meters
 * @param y Y Position in NED frame in meters
 * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
 * @param vx X velocity in NED frame in meter / s
 * @param vy Y velocity in NED frame in meter / s
 * @param vz Z velocity in NED frame in meter / s
 * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param yaw yaw setpoint in rad
 * @param yawRate yaw rate setpoint in rad/s
 */
case class SetPositionTargetLocalNed(timeBootMs: Int = 0, targetSystem: SystemId = 0, targetComponent: ComponentId = 0, coordinateFrame: MavFrame.Value = MavFrame(0), typeMask: Short = 0, x: Float = 0, y: Float = 0, z: Float = 0, vx: Float = 0, vy: Float = 0, vz: Float = 0, afx: Float = 0, afy: Float = 0, afz: Float = 0, yaw: Float = 0, yawRate: Float = 0)
extends Message with TargetComponent[SetPositionTargetLocalNed] {
  val _id = 84
  val _name = "SET_POSITION_TARGET_LOCAL_NED"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): SetPositionTargetLocalNed = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): SetPositionTargetLocalNed = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): SetPositionTargetLocalNed = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "SET_POSITION_TARGET_LOCAL_NED" + " timeBootMs=" + timeBootMs + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " coordinateFrame=" + coordinateFrame + " typeMask=" + typeMask + " x=" + x + " y=" + y + " z=" + z + " vx=" + vx + " vy=" + vy + " vz=" + vz + " afx=" + afx + " afy=" + afy + " afz=" + afz + " yaw=" + yaw + " yawRate=" + yawRate
}

/**
 * Set vehicle position, velocity and acceleration setpoint in local frame.
 * @param timeBootMs Timestamp in milliseconds since system boot
 * @param coordinateFrame Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
 * @param typeMask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
 * @param x X Position in NED frame in meters
 * @param y Y Position in NED frame in meters
 * @param z Z Position in NED frame in meters (note, altitude is negative in NED)
 * @param vx X velocity in NED frame in meter / s
 * @param vy Y velocity in NED frame in meter / s
 * @param vz Z velocity in NED frame in meter / s
 * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param yaw yaw setpoint in rad
 * @param yawRate yaw rate setpoint in rad/s
 */
case class PositionTargetLocalNed(timeBootMs: Int = 0, coordinateFrame: MavFrame.Value = MavFrame(0), typeMask: Short = 0, x: Float = 0, y: Float = 0, z: Float = 0, vx: Float = 0, vy: Float = 0, vz: Float = 0, afx: Float = 0, afy: Float = 0, afz: Float = 0, yaw: Float = 0, yawRate: Float = 0)
extends Message {
  val _id = 85
  val _name = "POSITION_TARGET_LOCAL_NED"
  val _bundle = Bundle.common
  override def toString = "POSITION_TARGET_LOCAL_NED" + " timeBootMs=" + timeBootMs + " coordinateFrame=" + coordinateFrame + " typeMask=" + typeMask + " x=" + x + " y=" + y + " z=" + z + " vx=" + vx + " vy=" + vy + " vz=" + vz + " afx=" + afx + " afy=" + afy + " afz=" + afz + " yaw=" + yaw + " yawRate=" + yawRate
}

/**
 * Set vehicle position, velocity and acceleration setpoint in the WGS84 coordinate system.
 * @param timeBootMs Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param coordinateFrame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
 * @param typeMask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
 * @param latInt X Position in WGS84 frame in 1e7 * meters
 * @param lonInt Y Position in WGS84 frame in 1e7 * meters
 * @param alt Altitude in meters in WGS84 altitude, not AMSL if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
 * @param vx X velocity in NED frame in meter / s
 * @param vy Y velocity in NED frame in meter / s
 * @param vz Z velocity in NED frame in meter / s
 * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param yaw yaw setpoint in rad
 * @param yawRate yaw rate setpoint in rad/s
 */
case class SetPositionTargetGlobalInt(timeBootMs: Int = 0, targetSystem: SystemId = 0, targetComponent: ComponentId = 0, coordinateFrame: MavFrame.Value = MavFrame(0), typeMask: Short = 0, latInt: Int = 0, lonInt: Int = 0, alt: Float = 0, vx: Float = 0, vy: Float = 0, vz: Float = 0, afx: Float = 0, afy: Float = 0, afz: Float = 0, yaw: Float = 0, yawRate: Float = 0)
extends Message with TargetComponent[SetPositionTargetGlobalInt] {
  val _id = 86
  val _name = "SET_POSITION_TARGET_GLOBAL_INT"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): SetPositionTargetGlobalInt = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): SetPositionTargetGlobalInt = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): SetPositionTargetGlobalInt = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "SET_POSITION_TARGET_GLOBAL_INT" + " timeBootMs=" + timeBootMs + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " coordinateFrame=" + coordinateFrame + " typeMask=" + typeMask + " latInt=" + latInt + " lonInt=" + lonInt + " alt=" + alt + " vx=" + vx + " vy=" + vy + " vz=" + vz + " afx=" + afx + " afy=" + afy + " afz=" + afz + " yaw=" + yaw + " yawRate=" + yawRate
}

/**
 * Set vehicle position, velocity and acceleration setpoint in the WGS84 coordinate system.
 * @param timeBootMs Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
 * @param coordinateFrame Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
 * @param typeMask Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
 * @param latInt X Position in WGS84 frame in 1e7 * meters
 * @param lonInt Y Position in WGS84 frame in 1e7 * meters
 * @param alt Altitude in meters in WGS84 altitude, not AMSL if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
 * @param vx X velocity in NED frame in meter / s
 * @param vy Y velocity in NED frame in meter / s
 * @param vz Z velocity in NED frame in meter / s
 * @param afx X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afy Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param afz Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
 * @param yaw yaw setpoint in rad
 * @param yawRate yaw rate setpoint in rad/s
 */
case class PositionTargetGlobalInt(timeBootMs: Int = 0, coordinateFrame: MavFrame.Value = MavFrame(0), typeMask: Short = 0, latInt: Int = 0, lonInt: Int = 0, alt: Float = 0, vx: Float = 0, vy: Float = 0, vz: Float = 0, afx: Float = 0, afy: Float = 0, afz: Float = 0, yaw: Float = 0, yawRate: Float = 0)
extends Message {
  val _id = 87
  val _name = "POSITION_TARGET_GLOBAL_INT"
  val _bundle = Bundle.common
  override def toString = "POSITION_TARGET_GLOBAL_INT" + " timeBootMs=" + timeBootMs + " coordinateFrame=" + coordinateFrame + " typeMask=" + typeMask + " latInt=" + latInt + " lonInt=" + lonInt + " alt=" + alt + " vx=" + vx + " vy=" + vy + " vz=" + vz + " afx=" + afx + " afy=" + afy + " afz=" + afz + " yaw=" + yaw + " yawRate=" + yawRate
}

/**
 * The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param x X Position
 * @param y Y Position
 * @param z Z Position
 * @param roll Roll
 * @param pitch Pitch
 * @param yaw Yaw
 */
case class LocalPositionNedSystemGlobalOffset(timeBootMs: Int = 0, x: Float = 0, y: Float = 0, z: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0)
extends Message {
  val _id = 89
  val _name = "LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET"
  val _bundle = Bundle.common
  override def toString = "LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET" + " timeBootMs=" + timeBootMs + " x=" + x + " y=" + y + " z=" + z + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw
}

/**
 * DEPRECATED PACKET! Suffers from missing airspeed fields and singularities due to Euler angles. Please use HIL_STATE_QUATERNION instead. Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations.
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param roll Roll angle (rad)
 * @param pitch Pitch angle (rad)
 * @param yaw Yaw angle (rad)
 * @param rollspeed Body frame roll / phi angular speed (rad/s)
 * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
 * @param yawspeed Body frame yaw / psi angular speed (rad/s)
 * @param lat Latitude, expressed as * 1E7
 * @param lon Longitude, expressed as * 1E7
 * @param alt Altitude in meters, expressed as * 1000 (millimeters)
 * @param vx Ground X Speed (Latitude), expressed as m/s * 100
 * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
 * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
 * @param xacc X acceleration (mg)
 * @param yacc Y acceleration (mg)
 * @param zacc Z acceleration (mg)
 */
case class HilState(timeUsec: Long = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, rollspeed: Float = 0, pitchspeed: Float = 0, yawspeed: Float = 0, lat: Int = 0, lon: Int = 0, alt: Int = 0, vx: Short = 0, vy: Short = 0, vz: Short = 0, xacc: Short = 0, yacc: Short = 0, zacc: Short = 0)
extends Message {
  val _id = 90
  val _name = "HIL_STATE"
  val _bundle = Bundle.common
  override def toString = "HIL_STATE" + " timeUsec=" + timeUsec + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " rollspeed=" + rollspeed + " pitchspeed=" + pitchspeed + " yawspeed=" + yawspeed + " lat=" + lat + " lon=" + lon + " alt=" + alt + " vx=" + vx + " vy=" + vy + " vz=" + vz + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc
}

/**
 * Sent from autopilot to simulation. Hardware in the loop control outputs
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param rollAilerons Control output -1 .. 1
 * @param pitchElevator Control output -1 .. 1
 * @param yawRudder Control output -1 .. 1
 * @param throttle Throttle 0 .. 1
 * @param aux1 Aux 1, -1 .. 1
 * @param aux2 Aux 2, -1 .. 1
 * @param aux3 Aux 3, -1 .. 1
 * @param aux4 Aux 4, -1 .. 1
 * @param mode System mode (MAV_MODE)
 * @param navMode Navigation mode (MAV_NAV_MODE)
 */
case class HilControls(timeUsec: Long = 0, rollAilerons: Float = 0, pitchElevator: Float = 0, yawRudder: Float = 0, throttle: Float = 0, aux1: Float = 0, aux2: Float = 0, aux3: Float = 0, aux4: Float = 0, mode: Byte = 0, navMode: Byte = 0)
extends Message {
  val _id = 91
  val _name = "HIL_CONTROLS"
  val _bundle = Bundle.common
  override def toString = "HIL_CONTROLS" + " timeUsec=" + timeUsec + " rollAilerons=" + rollAilerons + " pitchElevator=" + pitchElevator + " yawRudder=" + yawRudder + " throttle=" + throttle + " aux1=" + aux1 + " aux2=" + aux2 + " aux3=" + aux3 + " aux4=" + aux4 + " mode=" + mode + " navMode=" + navMode
}

/**
 * Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param chan1Raw RC channel 1 value, in microseconds
 * @param chan2Raw RC channel 2 value, in microseconds
 * @param chan3Raw RC channel 3 value, in microseconds
 * @param chan4Raw RC channel 4 value, in microseconds
 * @param chan5Raw RC channel 5 value, in microseconds
 * @param chan6Raw RC channel 6 value, in microseconds
 * @param chan7Raw RC channel 7 value, in microseconds
 * @param chan8Raw RC channel 8 value, in microseconds
 * @param chan9Raw RC channel 9 value, in microseconds
 * @param chan10Raw RC channel 10 value, in microseconds
 * @param chan11Raw RC channel 11 value, in microseconds
 * @param chan12Raw RC channel 12 value, in microseconds
 * @param rssi Receive signal strength indicator, 0: 0%, 255: 100%
 */
case class HilRcInputsRaw(timeUsec: Long = 0, chan1Raw: Short = 0, chan2Raw: Short = 0, chan3Raw: Short = 0, chan4Raw: Short = 0, chan5Raw: Short = 0, chan6Raw: Short = 0, chan7Raw: Short = 0, chan8Raw: Short = 0, chan9Raw: Short = 0, chan10Raw: Short = 0, chan11Raw: Short = 0, chan12Raw: Short = 0, rssi: Byte = 0)
extends Message {
  val _id = 92
  val _name = "HIL_RC_INPUTS_RAW"
  val _bundle = Bundle.common
  override def toString = "HIL_RC_INPUTS_RAW" + " timeUsec=" + timeUsec + " chan1Raw=" + chan1Raw + " chan2Raw=" + chan2Raw + " chan3Raw=" + chan3Raw + " chan4Raw=" + chan4Raw + " chan5Raw=" + chan5Raw + " chan6Raw=" + chan6Raw + " chan7Raw=" + chan7Raw + " chan8Raw=" + chan8Raw + " chan9Raw=" + chan9Raw + " chan10Raw=" + chan10Raw + " chan11Raw=" + chan11Raw + " chan12Raw=" + chan12Raw + " rssi=" + rssi
}

/**
 * Optical flow from a flow sensor (e.g. optical mouse sensor)
 * @param timeUsec Timestamp (UNIX)
 * @param sensorId Sensor ID
 * @param flowX Flow in pixels * 10 in x-sensor direction (dezi-pixels)
 * @param flowY Flow in pixels * 10 in y-sensor direction (dezi-pixels)
 * @param flowCompMX Flow in meters in x-sensor direction, angular-speed compensated
 * @param flowCompMY Flow in meters in y-sensor direction, angular-speed compensated
 * @param quality Optical flow quality / confidence. 0: bad, 255: maximum quality
 * @param groundDistance Ground distance in meters. Positive value: distance known. Negative value: Unknown distance
 */
case class OpticalFlow(timeUsec: Long = 0, sensorId: Byte = 0, flowX: Short = 0, flowY: Short = 0, flowCompMX: Float = 0, flowCompMY: Float = 0, quality: Byte = 0, groundDistance: Float = 0)
extends Message {
  val _id = 100
  val _name = "OPTICAL_FLOW"
  val _bundle = Bundle.common
  override def toString = "OPTICAL_FLOW" + " timeUsec=" + timeUsec + " sensorId=" + sensorId + " flowX=" + flowX + " flowY=" + flowY + " flowCompMX=" + flowCompMX + " flowCompMY=" + flowCompMY + " quality=" + quality + " groundDistance=" + groundDistance
}

/**
 * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param x Global X position
 * @param y Global Y position
 * @param z Global Z position
 * @param roll Roll angle in rad
 * @param pitch Pitch angle in rad
 * @param yaw Yaw angle in rad
 */
case class GlobalVisionPositionEstimate(usec: Long = 0, x: Float = 0, y: Float = 0, z: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0)
extends Message {
  val _id = 101
  val _name = "GLOBAL_VISION_POSITION_ESTIMATE"
  val _bundle = Bundle.common
  override def toString = "GLOBAL_VISION_POSITION_ESTIMATE" + " usec=" + usec + " x=" + x + " y=" + y + " z=" + z + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw
}

/**
 * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param x Global X position
 * @param y Global Y position
 * @param z Global Z position
 * @param roll Roll angle in rad
 * @param pitch Pitch angle in rad
 * @param yaw Yaw angle in rad
 */
case class VisionPositionEstimate(usec: Long = 0, x: Float = 0, y: Float = 0, z: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0)
extends Message {
  val _id = 102
  val _name = "VISION_POSITION_ESTIMATE"
  val _bundle = Bundle.common
  override def toString = "VISION_POSITION_ESTIMATE" + " usec=" + usec + " x=" + x + " y=" + y + " z=" + z + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw
}

/**
 * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param x Global X speed
 * @param y Global Y speed
 * @param z Global Z speed
 */
case class VisionSpeedEstimate(usec: Long = 0, x: Float = 0, y: Float = 0, z: Float = 0)
extends Message {
  val _id = 103
  val _name = "VISION_SPEED_ESTIMATE"
  val _bundle = Bundle.common
  override def toString = "VISION_SPEED_ESTIMATE" + " usec=" + usec + " x=" + x + " y=" + y + " z=" + z
}

/**
 * @param usec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param x Global X position
 * @param y Global Y position
 * @param z Global Z position
 * @param roll Roll angle in rad
 * @param pitch Pitch angle in rad
 * @param yaw Yaw angle in rad
 */
case class ViconPositionEstimate(usec: Long = 0, x: Float = 0, y: Float = 0, z: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0)
extends Message {
  val _id = 104
  val _name = "VICON_POSITION_ESTIMATE"
  val _bundle = Bundle.common
  override def toString = "VICON_POSITION_ESTIMATE" + " usec=" + usec + " x=" + x + " y=" + y + " z=" + z + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw
}

/**
 * The IMU readings in SI units in NED body frame
 * @param timeUsec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param xacc X acceleration (m/s^2)
 * @param yacc Y acceleration (m/s^2)
 * @param zacc Z acceleration (m/s^2)
 * @param xgyro Angular speed around X axis (rad / sec)
 * @param ygyro Angular speed around Y axis (rad / sec)
 * @param zgyro Angular speed around Z axis (rad / sec)
 * @param xmag X Magnetic field (Gauss)
 * @param ymag Y Magnetic field (Gauss)
 * @param zmag Z Magnetic field (Gauss)
 * @param absPressure Absolute pressure in millibar
 * @param diffPressure Differential pressure in millibar
 * @param pressureAlt Altitude calculated from pressure
 * @param temperature Temperature in degrees celsius
 * @param fieldsUpdated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
 */
case class HighresImu(timeUsec: Long = 0, xacc: Float = 0, yacc: Float = 0, zacc: Float = 0, xgyro: Float = 0, ygyro: Float = 0, zgyro: Float = 0, xmag: Float = 0, ymag: Float = 0, zmag: Float = 0, absPressure: Float = 0, diffPressure: Float = 0, pressureAlt: Float = 0, temperature: Float = 0, fieldsUpdated: Short = 0)
extends Message {
  val _id = 105
  val _name = "HIGHRES_IMU"
  val _bundle = Bundle.common
  override def toString = "HIGHRES_IMU" + " timeUsec=" + timeUsec + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc + " xgyro=" + xgyro + " ygyro=" + ygyro + " zgyro=" + zgyro + " xmag=" + xmag + " ymag=" + ymag + " zmag=" + zmag + " absPressure=" + absPressure + " diffPressure=" + diffPressure + " pressureAlt=" + pressureAlt + " temperature=" + temperature + " fieldsUpdated=" + fieldsUpdated
}

/**
 * Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)
 * @param timeUsec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param sensorId Sensor ID
 * @param integrationTimeUs Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
 * @param integratedX Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
 * @param integratedY Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
 * @param integratedXgyro RH rotation around X axis (rad)
 * @param integratedYgyro RH rotation around Y axis (rad)
 * @param integratedZgyro RH rotation around Z axis (rad)
 * @param temperature Temperature * 100 in centi-degrees Celsius
 * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
 * @param timeDeltaDistanceUs Time in microseconds since the distance was sampled.
 * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
 */
case class OpticalFlowRad(timeUsec: Long = 0, sensorId: Byte = 0, integrationTimeUs: Int = 0, integratedX: Float = 0, integratedY: Float = 0, integratedXgyro: Float = 0, integratedYgyro: Float = 0, integratedZgyro: Float = 0, temperature: Short = 0, quality: Byte = 0, timeDeltaDistanceUs: Int = 0, distance: Float = 0)
extends Message {
  val _id = 106
  val _name = "OPTICAL_FLOW_RAD"
  val _bundle = Bundle.common
  override def toString = "OPTICAL_FLOW_RAD" + " timeUsec=" + timeUsec + " sensorId=" + sensorId + " integrationTimeUs=" + integrationTimeUs + " integratedX=" + integratedX + " integratedY=" + integratedY + " integratedXgyro=" + integratedXgyro + " integratedYgyro=" + integratedYgyro + " integratedZgyro=" + integratedZgyro + " temperature=" + temperature + " quality=" + quality + " timeDeltaDistanceUs=" + timeDeltaDistanceUs + " distance=" + distance
}

/**
 * The IMU readings in SI units in NED body frame
 * @param timeUsec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param xacc X acceleration (m/s^2)
 * @param yacc Y acceleration (m/s^2)
 * @param zacc Z acceleration (m/s^2)
 * @param xgyro Angular speed around X axis in body frame (rad / sec)
 * @param ygyro Angular speed around Y axis in body frame (rad / sec)
 * @param zgyro Angular speed around Z axis in body frame (rad / sec)
 * @param xmag X Magnetic field (Gauss)
 * @param ymag Y Magnetic field (Gauss)
 * @param zmag Z Magnetic field (Gauss)
 * @param absPressure Absolute pressure in millibar
 * @param diffPressure Differential pressure (airspeed) in millibar
 * @param pressureAlt Altitude calculated from pressure
 * @param temperature Temperature in degrees celsius
 * @param fieldsUpdated Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
 */
case class HilSensor(timeUsec: Long = 0, xacc: Float = 0, yacc: Float = 0, zacc: Float = 0, xgyro: Float = 0, ygyro: Float = 0, zgyro: Float = 0, xmag: Float = 0, ymag: Float = 0, zmag: Float = 0, absPressure: Float = 0, diffPressure: Float = 0, pressureAlt: Float = 0, temperature: Float = 0, fieldsUpdated: Int = 0)
extends Message {
  val _id = 107
  val _name = "HIL_SENSOR"
  val _bundle = Bundle.common
  override def toString = "HIL_SENSOR" + " timeUsec=" + timeUsec + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc + " xgyro=" + xgyro + " ygyro=" + ygyro + " zgyro=" + zgyro + " xmag=" + xmag + " ymag=" + ymag + " zmag=" + zmag + " absPressure=" + absPressure + " diffPressure=" + diffPressure + " pressureAlt=" + pressureAlt + " temperature=" + temperature + " fieldsUpdated=" + fieldsUpdated
}

/**
 * Status of simulation environment, if used
 * @param q1 True attitude quaternion component 1, w (1 in null-rotation)
 * @param q2 True attitude quaternion component 2, x (0 in null-rotation)
 * @param q3 True attitude quaternion component 3, y (0 in null-rotation)
 * @param q4 True attitude quaternion component 4, z (0 in null-rotation)
 * @param roll Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
 * @param pitch Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
 * @param yaw Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
 * @param xacc X acceleration m/s/s
 * @param yacc Y acceleration m/s/s
 * @param zacc Z acceleration m/s/s
 * @param xgyro Angular speed around X axis rad/s
 * @param ygyro Angular speed around Y axis rad/s
 * @param zgyro Angular speed around Z axis rad/s
 * @param lat Latitude in degrees
 * @param lon Longitude in degrees
 * @param alt Altitude in meters
 * @param stdDevHorz Horizontal position standard deviation
 * @param stdDevVert Vertical position standard deviation
 * @param vn True velocity in m/s in NORTH direction in earth-fixed NED frame
 * @param ve True velocity in m/s in EAST direction in earth-fixed NED frame
 * @param vd True velocity in m/s in DOWN direction in earth-fixed NED frame
 */
case class SimState(q1: Float = 0, q2: Float = 0, q3: Float = 0, q4: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, xacc: Float = 0, yacc: Float = 0, zacc: Float = 0, xgyro: Float = 0, ygyro: Float = 0, zgyro: Float = 0, lat: Float = 0, lon: Float = 0, alt: Float = 0, stdDevHorz: Float = 0, stdDevVert: Float = 0, vn: Float = 0, ve: Float = 0, vd: Float = 0)
extends Message {
  val _id = 108
  val _name = "SIM_STATE"
  val _bundle = Bundle.common
  override def toString = "SIM_STATE" + " q1=" + q1 + " q2=" + q2 + " q3=" + q3 + " q4=" + q4 + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc + " xgyro=" + xgyro + " ygyro=" + ygyro + " zgyro=" + zgyro + " lat=" + lat + " lon=" + lon + " alt=" + alt + " stdDevHorz=" + stdDevHorz + " stdDevVert=" + stdDevVert + " vn=" + vn + " ve=" + ve + " vd=" + vd
}

/**
 * Status generated by radio
 * @param rssi local signal strength
 * @param remrssi remote signal strength
 * @param txbuf how full the tx buffer is as a percentage
 * @param noise background noise level
 * @param remnoise remote background noise level
 * @param rxerrors receive errors
 * @param fixed count of error corrected packets
 */
case class RadioStatus(rssi: Byte = 0, remrssi: Byte = 0, txbuf: Byte = 0, noise: Byte = 0, remnoise: Byte = 0, rxerrors: Short = 0, fixed: Short = 0)
extends Message {
  val _id = 109
  val _name = "RADIO_STATUS"
  val _bundle = Bundle.common
  override def toString = "RADIO_STATUS" + " rssi=" + rssi + " remrssi=" + remrssi + " txbuf=" + txbuf + " noise=" + noise + " remnoise=" + remnoise + " rxerrors=" + rxerrors + " fixed=" + fixed
}

/**
 * File transfer message
 * @param targetNetwork Network ID (0 for broadcast)
 * @param targetSystem System ID (0 for broadcast)
 * @param targetComponent Component ID (0 for broadcast)
 * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
 */
case class FileTransferProtocol(targetNetwork: Byte = 0, targetSystem: SystemId = 0, targetComponent: ComponentId = 0, payload: Vector[Byte] = Vector.fill(251)(0))
extends Message with TargetComponent[FileTransferProtocol] {
  require(payload.length <= 251)
  val _id = 110
  val _name = "FILE_TRANSFER_PROTOCOL"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): FileTransferProtocol = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FileTransferProtocol = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FileTransferProtocol = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FILE_TRANSFER_PROTOCOL" + " targetNetwork=" + targetNetwork + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " payload=" + payload
}

/**
 * Time synchronization message.
 * @param tc1 Time sync timestamp 1
 * @param ts1 Time sync timestamp 2
 */
case class Timesync(tc1: Long = 0, ts1: Long = 0)
extends Message {
  val _id = 111
  val _name = "TIMESYNC"
  val _bundle = Bundle.common
  override def toString = "TIMESYNC" + " tc1=" + tc1 + " ts1=" + ts1
}

/**
 * The global position, as returned by the Global Positioning System (GPS). This is
                 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame).
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param fixType 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
 * @param lat Latitude (WGS84), in degrees * 1E7
 * @param lon Longitude (WGS84), in degrees * 1E7
 * @param alt Altitude (WGS84), in meters * 1000 (positive for up)
 * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
 * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535
 * @param vel GPS ground speed (m/s * 100). If unknown, set to: 65535
 * @param vn GPS velocity in cm/s in NORTH direction in earth-fixed NED frame
 * @param ve GPS velocity in cm/s in EAST direction in earth-fixed NED frame
 * @param vd GPS velocity in cm/s in DOWN direction in earth-fixed NED frame
 * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
 * @param satellitesVisible Number of satellites visible. If unknown, set to 255
 */
case class HilGps(timeUsec: Long = 0, fixType: Byte = 0, lat: Int = 0, lon: Int = 0, alt: Int = 0, eph: Short = 0, epv: Short = 0, vel: Short = 0, vn: Short = 0, ve: Short = 0, vd: Short = 0, cog: Short = 0, satellitesVisible: Byte = 0)
extends Message {
  val _id = 113
  val _name = "HIL_GPS"
  val _bundle = Bundle.common
  override def toString = "HIL_GPS" + " timeUsec=" + timeUsec + " fixType=" + fixType + " lat=" + lat + " lon=" + lon + " alt=" + alt + " eph=" + eph + " epv=" + epv + " vel=" + vel + " vn=" + vn + " ve=" + ve + " vd=" + vd + " cog=" + cog + " satellitesVisible=" + satellitesVisible
}

/**
 * Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)
 * @param timeUsec Timestamp (microseconds, synced to UNIX time or since system boot)
 * @param sensorId Sensor ID
 * @param integrationTimeUs Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
 * @param integratedX Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
 * @param integratedY Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
 * @param integratedXgyro RH rotation around X axis (rad)
 * @param integratedYgyro RH rotation around Y axis (rad)
 * @param integratedZgyro RH rotation around Z axis (rad)
 * @param temperature Temperature * 100 in centi-degrees Celsius
 * @param quality Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
 * @param timeDeltaDistanceUs Time in microseconds since the distance was sampled.
 * @param distance Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
 */
case class HilOpticalFlow(timeUsec: Long = 0, sensorId: Byte = 0, integrationTimeUs: Int = 0, integratedX: Float = 0, integratedY: Float = 0, integratedXgyro: Float = 0, integratedYgyro: Float = 0, integratedZgyro: Float = 0, temperature: Short = 0, quality: Byte = 0, timeDeltaDistanceUs: Int = 0, distance: Float = 0)
extends Message {
  val _id = 114
  val _name = "HIL_OPTICAL_FLOW"
  val _bundle = Bundle.common
  override def toString = "HIL_OPTICAL_FLOW" + " timeUsec=" + timeUsec + " sensorId=" + sensorId + " integrationTimeUs=" + integrationTimeUs + " integratedX=" + integratedX + " integratedY=" + integratedY + " integratedXgyro=" + integratedXgyro + " integratedYgyro=" + integratedYgyro + " integratedZgyro=" + integratedZgyro + " temperature=" + temperature + " quality=" + quality + " timeDeltaDistanceUs=" + timeDeltaDistanceUs + " distance=" + distance
}

/**
 * Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations.
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param attitudeQuaternion Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
 * @param rollspeed Body frame roll / phi angular speed (rad/s)
 * @param pitchspeed Body frame pitch / theta angular speed (rad/s)
 * @param yawspeed Body frame yaw / psi angular speed (rad/s)
 * @param lat Latitude, expressed as * 1E7
 * @param lon Longitude, expressed as * 1E7
 * @param alt Altitude in meters, expressed as * 1000 (millimeters)
 * @param vx Ground X Speed (Latitude), expressed as m/s * 100
 * @param vy Ground Y Speed (Longitude), expressed as m/s * 100
 * @param vz Ground Z Speed (Altitude), expressed as m/s * 100
 * @param indAirspeed Indicated airspeed, expressed as m/s * 100
 * @param trueAirspeed True airspeed, expressed as m/s * 100
 * @param xacc X acceleration (mg)
 * @param yacc Y acceleration (mg)
 * @param zacc Z acceleration (mg)
 */
case class HilStateQuaternion(timeUsec: Long = 0, attitudeQuaternion: (Float,Float,Float,Float) = (0,0,0,0), rollspeed: Float = 0, pitchspeed: Float = 0, yawspeed: Float = 0, lat: Int = 0, lon: Int = 0, alt: Int = 0, vx: Short = 0, vy: Short = 0, vz: Short = 0, indAirspeed: Short = 0, trueAirspeed: Short = 0, xacc: Short = 0, yacc: Short = 0, zacc: Short = 0)
extends Message {
  val _id = 115
  val _name = "HIL_STATE_QUATERNION"
  val _bundle = Bundle.common
  override def toString = "HIL_STATE_QUATERNION" + " timeUsec=" + timeUsec + " attitudeQuaternion=" + attitudeQuaternion + " rollspeed=" + rollspeed + " pitchspeed=" + pitchspeed + " yawspeed=" + yawspeed + " lat=" + lat + " lon=" + lon + " alt=" + alt + " vx=" + vx + " vy=" + vy + " vz=" + vz + " indAirspeed=" + indAirspeed + " trueAirspeed=" + trueAirspeed + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc
}

/**
 * The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param xacc X acceleration (mg)
 * @param yacc Y acceleration (mg)
 * @param zacc Z acceleration (mg)
 * @param xgyro Angular speed around X axis (millirad /sec)
 * @param ygyro Angular speed around Y axis (millirad /sec)
 * @param zgyro Angular speed around Z axis (millirad /sec)
 * @param xmag X Magnetic field (milli tesla)
 * @param ymag Y Magnetic field (milli tesla)
 * @param zmag Z Magnetic field (milli tesla)
 */
case class ScaledImu2(timeBootMs: Int = 0, xacc: Short = 0, yacc: Short = 0, zacc: Short = 0, xgyro: Short = 0, ygyro: Short = 0, zgyro: Short = 0, xmag: Short = 0, ymag: Short = 0, zmag: Short = 0)
extends Message {
  val _id = 116
  val _name = "SCALED_IMU2"
  val _bundle = Bundle.common
  override def toString = "SCALED_IMU2" + " timeBootMs=" + timeBootMs + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc + " xgyro=" + xgyro + " ygyro=" + ygyro + " zgyro=" + zgyro + " xmag=" + xmag + " ymag=" + ymag + " zmag=" + zmag
}

/**
 * Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param start First log id (0 for first available)
 * @param end Last log id (0xffff for last available)
 */
case class LogRequestList(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, start: Short = 0, end: Short = 0)
extends Message with TargetComponent[LogRequestList] {
  val _id = 117
  val _name = "LOG_REQUEST_LIST"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): LogRequestList = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): LogRequestList = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): LogRequestList = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "LOG_REQUEST_LIST" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " start=" + start + " end=" + end
}

/**
 * Reply to LOG_REQUEST_LIST
 * @param id Log id
 * @param numLogs Total number of logs
 * @param lastLogNum High log number
 * @param timeUtc UTC timestamp of log in seconds since 1970, or 0 if not available
 * @param size Size of the log (may be approximate) in bytes
 */
case class LogEntry(id: Short = 0, numLogs: Short = 0, lastLogNum: Short = 0, timeUtc: Int = 0, size: Int = 0)
extends Message {
  val _id = 118
  val _name = "LOG_ENTRY"
  val _bundle = Bundle.common
  override def toString = "LOG_ENTRY" + " id=" + id + " numLogs=" + numLogs + " lastLogNum=" + lastLogNum + " timeUtc=" + timeUtc + " size=" + size
}

/**
 * Request a chunk of a log
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param id Log id (from LOG_ENTRY reply)
 * @param ofs Offset into the log
 * @param count Number of bytes
 */
case class LogRequestData(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, id: Short = 0, ofs: Int = 0, count: Int = 0)
extends Message with TargetComponent[LogRequestData] {
  val _id = 119
  val _name = "LOG_REQUEST_DATA"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): LogRequestData = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): LogRequestData = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): LogRequestData = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "LOG_REQUEST_DATA" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " id=" + id + " ofs=" + ofs + " count=" + count
}

/**
 * Reply to LOG_REQUEST_DATA
 * @param id Log id (from LOG_ENTRY reply)
 * @param ofs Offset into the log
 * @param count Number of bytes (zero for end of log)
 * @param data log data
 */
case class LogData(id: Short = 0, ofs: Int = 0, count: Byte = 0, data: Vector[Byte] = Vector.fill(90)(0))
extends Message {
  require(data.length <= 90)
  val _id = 120
  val _name = "LOG_DATA"
  val _bundle = Bundle.common
  override def toString = "LOG_DATA" + " id=" + id + " ofs=" + ofs + " count=" + count + " data=" + data
}

/**
 * Erase all logs
 * @param targetSystem System ID
 * @param targetComponent Component ID
 */
case class LogErase(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Message with TargetComponent[LogErase] {
  val _id = 121
  val _name = "LOG_ERASE"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): LogErase = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): LogErase = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): LogErase = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "LOG_ERASE" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent
}

/**
 * Stop log transfer and resume normal logging
 * @param targetSystem System ID
 * @param targetComponent Component ID
 */
case class LogRequestEnd(targetSystem: SystemId = 0, targetComponent: ComponentId = 0)
extends Message with TargetComponent[LogRequestEnd] {
  val _id = 122
  val _name = "LOG_REQUEST_END"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): LogRequestEnd = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): LogRequestEnd = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): LogRequestEnd = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "LOG_REQUEST_END" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent
}

/**
 * data for injecting into the onboard GPS (used for DGPS)
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param len data length
 * @param data raw data (110 is enough for 12 satellites of RTCMv2)
 */
case class GpsInjectData(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, len: Byte = 0, data: Vector[Byte] = Vector.fill(110)(0))
extends Message with TargetComponent[GpsInjectData] {
  require(data.length <= 110)
  val _id = 123
  val _name = "GPS_INJECT_DATA"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): GpsInjectData = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): GpsInjectData = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): GpsInjectData = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "GPS_INJECT_DATA" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " len=" + len + " data=" + data
}

/**
 * Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame).
 * @param timeUsec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param fixType 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
 * @param lat Latitude (WGS84), in degrees * 1E7
 * @param lon Longitude (WGS84), in degrees * 1E7
 * @param alt Altitude (WGS84), in meters * 1000 (positive for up)
 * @param eph GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
 * @param epv GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
 * @param vel GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
 * @param cog Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
 * @param satellitesVisible Number of satellites visible. If unknown, set to 255
 * @param dgpsNumch Number of DGPS satellites
 * @param dgpsAge Age of DGPS info
 */
case class Gps2Raw(timeUsec: Long = 0, fixType: Byte = 0, lat: Int = 0, lon: Int = 0, alt: Int = 0, eph: Short = 0, epv: Short = 0, vel: Short = 0, cog: Short = 0, satellitesVisible: Byte = 0, dgpsNumch: Byte = 0, dgpsAge: Int = 0)
extends Message {
  val _id = 124
  val _name = "GPS2_RAW"
  val _bundle = Bundle.common
  override def toString = "GPS2_RAW" + " timeUsec=" + timeUsec + " fixType=" + fixType + " lat=" + lat + " lon=" + lon + " alt=" + alt + " eph=" + eph + " epv=" + epv + " vel=" + vel + " cog=" + cog + " satellitesVisible=" + satellitesVisible + " dgpsNumch=" + dgpsNumch + " dgpsAge=" + dgpsAge
}

/**
 * Power supply status
 * @param vcc 5V rail voltage in millivolts
 * @param vservo servo rail voltage in millivolts
 * @param flags power supply status flags (see MAV_POWER_STATUS enum)
 */
case class PowerStatus(vcc: Short = 0, vservo: Short = 0, flags: Short = 0)
extends Message {
  val _id = 125
  val _name = "POWER_STATUS"
  val _bundle = Bundle.common
  override def toString = "POWER_STATUS" + " vcc=" + vcc + " vservo=" + vservo + " flags=" + flags
}

/**
 * Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate.
 * @param device See SERIAL_CONTROL_DEV enum
 * @param flags See SERIAL_CONTROL_FLAG enum
 * @param timeout Timeout for reply data in milliseconds
 * @param baudrate Baudrate of transfer. Zero means no change.
 * @param count how many bytes in this transfer
 * @param data serial data
 */
case class SerialControl(device: Byte = 0, flags: Byte = 0, timeout: Short = 0, baudrate: Int = 0, count: Byte = 0, data: Vector[Byte] = Vector.fill(70)(0))
extends Message {
  require(data.length <= 70)
  val _id = 126
  val _name = "SERIAL_CONTROL"
  val _bundle = Bundle.common
  override def toString = "SERIAL_CONTROL" + " device=" + device + " flags=" + flags + " timeout=" + timeout + " baudrate=" + baudrate + " count=" + count + " data=" + data
}

/**
 * RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
 * @param timeLastBaselineMs Time since boot of last baseline message received in ms.
 * @param rtkReceiverId Identification of connected RTK receiver.
 * @param wn GPS Week Number of last baseline
 * @param tow GPS Time of Week of last baseline
 * @param rtkHealth GPS-specific health report for RTK data.
 * @param rtkRate Rate of baseline messages being received by GPS, in HZ
 * @param nsats Current number of sats used for RTK calculation.
 * @param baselineCoordsType Coordinate system of baseline. 0 == ECEF, 1 == NED
 * @param baselineAMm Current baseline in ECEF x or NED north component in mm.
 * @param baselineBMm Current baseline in ECEF y or NED east component in mm.
 * @param baselineCMm Current baseline in ECEF z or NED down component in mm.
 * @param accuracy Current estimate of baseline accuracy.
 * @param iarNumHypotheses Current number of integer ambiguity hypotheses.
 */
case class GpsRtk(timeLastBaselineMs: Int = 0, rtkReceiverId: Byte = 0, wn: Short = 0, tow: Int = 0, rtkHealth: Byte = 0, rtkRate: Byte = 0, nsats: Byte = 0, baselineCoordsType: Byte = 0, baselineAMm: Int = 0, baselineBMm: Int = 0, baselineCMm: Int = 0, accuracy: Int = 0, iarNumHypotheses: Int = 0)
extends Message {
  val _id = 127
  val _name = "GPS_RTK"
  val _bundle = Bundle.common
  override def toString = "GPS_RTK" + " timeLastBaselineMs=" + timeLastBaselineMs + " rtkReceiverId=" + rtkReceiverId + " wn=" + wn + " tow=" + tow + " rtkHealth=" + rtkHealth + " rtkRate=" + rtkRate + " nsats=" + nsats + " baselineCoordsType=" + baselineCoordsType + " baselineAMm=" + baselineAMm + " baselineBMm=" + baselineBMm + " baselineCMm=" + baselineCMm + " accuracy=" + accuracy + " iarNumHypotheses=" + iarNumHypotheses
}

/**
 * RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
 * @param timeLastBaselineMs Time since boot of last baseline message received in ms.
 * @param rtkReceiverId Identification of connected RTK receiver.
 * @param wn GPS Week Number of last baseline
 * @param tow GPS Time of Week of last baseline
 * @param rtkHealth GPS-specific health report for RTK data.
 * @param rtkRate Rate of baseline messages being received by GPS, in HZ
 * @param nsats Current number of sats used for RTK calculation.
 * @param baselineCoordsType Coordinate system of baseline. 0 == ECEF, 1 == NED
 * @param baselineAMm Current baseline in ECEF x or NED north component in mm.
 * @param baselineBMm Current baseline in ECEF y or NED east component in mm.
 * @param baselineCMm Current baseline in ECEF z or NED down component in mm.
 * @param accuracy Current estimate of baseline accuracy.
 * @param iarNumHypotheses Current number of integer ambiguity hypotheses.
 */
case class Gps2Rtk(timeLastBaselineMs: Int = 0, rtkReceiverId: Byte = 0, wn: Short = 0, tow: Int = 0, rtkHealth: Byte = 0, rtkRate: Byte = 0, nsats: Byte = 0, baselineCoordsType: Byte = 0, baselineAMm: Int = 0, baselineBMm: Int = 0, baselineCMm: Int = 0, accuracy: Int = 0, iarNumHypotheses: Int = 0)
extends Message {
  val _id = 128
  val _name = "GPS2_RTK"
  val _bundle = Bundle.common
  override def toString = "GPS2_RTK" + " timeLastBaselineMs=" + timeLastBaselineMs + " rtkReceiverId=" + rtkReceiverId + " wn=" + wn + " tow=" + tow + " rtkHealth=" + rtkHealth + " rtkRate=" + rtkRate + " nsats=" + nsats + " baselineCoordsType=" + baselineCoordsType + " baselineAMm=" + baselineAMm + " baselineBMm=" + baselineBMm + " baselineCMm=" + baselineCMm + " accuracy=" + accuracy + " iarNumHypotheses=" + iarNumHypotheses
}

/**
 * @param `type` type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)
 * @param size total data size in bytes (set on ACK only)
 * @param width Width of a matrix or image
 * @param height Height of a matrix or image
 * @param packets number of packets beeing sent (set on ACK only)
 * @param payload payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)
 * @param jpgQuality JPEG quality out of [1,100]
 */
case class DataTransmissionHandshake(`type`: Byte = 0, size: Int = 0, width: Short = 0, height: Short = 0, packets: Short = 0, payload: Byte = 0, jpgQuality: Byte = 0)
extends Message {
  val _id = 130
  val _name = "DATA_TRANSMISSION_HANDSHAKE"
  val _bundle = Bundle.common
  override def toString = "DATA_TRANSMISSION_HANDSHAKE" + " type=" + `type` + " size=" + size + " width=" + width + " height=" + height + " packets=" + packets + " payload=" + payload + " jpgQuality=" + jpgQuality
}

/**
 * @param seqnr sequence number (starting with 0 on every transmission)
 * @param data image data bytes
 */
case class EncapsulatedData(seqnr: Short = 0, data: Vector[Byte] = Vector.fill(253)(0))
extends Message {
  require(data.length <= 253)
  val _id = 131
  val _name = "ENCAPSULATED_DATA"
  val _bundle = Bundle.common
  override def toString = "ENCAPSULATED_DATA" + " seqnr=" + seqnr + " data=" + data
}

/**
 * @param timeBootMs Time since system boot
 * @param minDistance Minimum distance the sensor can measure in centimeters
 * @param maxDistance Maximum distance the sensor can measure in centimeters
 * @param currentDistance Current distance reading
 * @param `type` Type from MAV_DISTANCE_SENSOR enum.
 * @param id Onboard ID of the sensor
 * @param orientation Direction the sensor faces from FIXME enum.
 * @param covariance Measurement covariance in centimeters, 0 for unknown / invalid readings
 */
case class DistanceSensor(timeBootMs: Int = 0, minDistance: Short = 0, maxDistance: Short = 0, currentDistance: Short = 0, `type`: Byte = 0, id: Byte = 0, orientation: Byte = 0, covariance: Byte = 0)
extends Message {
  val _id = 132
  val _name = "DISTANCE_SENSOR"
  val _bundle = Bundle.common
  override def toString = "DISTANCE_SENSOR" + " timeBootMs=" + timeBootMs + " minDistance=" + minDistance + " maxDistance=" + maxDistance + " currentDistance=" + currentDistance + " type=" + `type` + " id=" + id + " orientation=" + orientation + " covariance=" + covariance
}

/**
 * Request for terrain data and terrain status
 * @param lat Latitude of SW corner of first grid (degrees *10^7)
 * @param lon Longitude of SW corner of first grid (in degrees *10^7)
 * @param gridSpacing Grid spacing in meters
 * @param mask Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
 */
case class TerrainRequest(lat: Int = 0, lon: Int = 0, gridSpacing: Short = 0, mask: Long = 0)
extends Message {
  val _id = 133
  val _name = "TERRAIN_REQUEST"
  val _bundle = Bundle.common
  override def toString = "TERRAIN_REQUEST" + " lat=" + lat + " lon=" + lon + " gridSpacing=" + gridSpacing + " mask=" + mask
}

/**
 * Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST
 * @param lat Latitude of SW corner of first grid (degrees *10^7)
 * @param lon Longitude of SW corner of first grid (in degrees *10^7)
 * @param gridSpacing Grid spacing in meters
 * @param gridbit bit within the terrain request mask
 * @param data Terrain data in meters AMSL
 */
case class TerrainData(lat: Int = 0, lon: Int = 0, gridSpacing: Short = 0, gridbit: Byte = 0, data: Vector[Short] = Vector.fill(16)(0))
extends Message {
  require(data.length <= 16)
  val _id = 134
  val _name = "TERRAIN_DATA"
  val _bundle = Bundle.common
  override def toString = "TERRAIN_DATA" + " lat=" + lat + " lon=" + lon + " gridSpacing=" + gridSpacing + " gridbit=" + gridbit + " data=" + data
}

/**
 * Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle has all terrain data needed for a mission.
 * @param lat Latitude (degrees *10^7)
 * @param lon Longitude (degrees *10^7)
 */
case class TerrainCheck(lat: Int = 0, lon: Int = 0)
extends Message {
  val _id = 135
  val _name = "TERRAIN_CHECK"
  val _bundle = Bundle.common
  override def toString = "TERRAIN_CHECK" + " lat=" + lat + " lon=" + lon
}

/**
 * Response from a TERRAIN_CHECK request
 * @param lat Latitude (degrees *10^7)
 * @param lon Longitude (degrees *10^7)
 * @param spacing grid spacing (zero if terrain at this location unavailable)
 * @param terrainHeight Terrain height in meters AMSL
 * @param currentHeight Current vehicle height above lat/lon terrain height (meters)
 * @param pending Number of 4x4 terrain blocks waiting to be received or read from disk
 * @param loaded Number of 4x4 terrain blocks in memory
 */
case class TerrainReport(lat: Int = 0, lon: Int = 0, spacing: Short = 0, terrainHeight: Float = 0, currentHeight: Float = 0, pending: Short = 0, loaded: Short = 0)
extends Message {
  val _id = 136
  val _name = "TERRAIN_REPORT"
  val _bundle = Bundle.common
  override def toString = "TERRAIN_REPORT" + " lat=" + lat + " lon=" + lon + " spacing=" + spacing + " terrainHeight=" + terrainHeight + " currentHeight=" + currentHeight + " pending=" + pending + " loaded=" + loaded
}

/**
 * Battery information
 * @param id Battery ID
 * @param batteryFunction Function of the battery
 * @param `type` Type (chemistry) of the battery
 * @param temperature Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.
 * @param voltages Battery voltage of cells, in millivolts (1 = 1 millivolt)
 * @param currentBattery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
 * @param currentConsumed Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
 * @param energyConsumed Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
 * @param batteryRemaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
 */
case class BatteryStatus(id: Byte = 0, batteryFunction: MavBatteryFunction.Value = MavBatteryFunction(0), `type`: MavBatteryType.Value = MavBatteryType(0), temperature: Short = 0, voltages: Vector[Short] = Vector.fill(10)(0), currentBattery: Short = 0, currentConsumed: Int = 0, energyConsumed: Int = 0, batteryRemaining: Byte = 0)
extends Message {
  require(voltages.length <= 10)
  val _id = 147
  val _name = "BATTERY_STATUS"
  val _bundle = Bundle.common
  override def toString = "BATTERY_STATUS" + " id=" + id + " batteryFunction=" + batteryFunction + " type=" + `type` + " temperature=" + temperature + " voltages=" + voltages + " currentBattery=" + currentBattery + " currentConsumed=" + currentConsumed + " energyConsumed=" + energyConsumed + " batteryRemaining=" + batteryRemaining
}

/**
 * Version and capability of autopilot software
 * @param capabilities bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)
 * @param version Firmware version number
 * @param customVersion Custom version field, commonly the first 8 bytes (16 characters) of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
 */
case class AutopilotVersion(capabilities: Long = 0, version: Int = 0, customVersion: Vector[Byte] = Vector.fill(8)(0))
extends Message {
  require(customVersion.length <= 8)
  val _id = 148
  val _name = "AUTOPILOT_VERSION"
  val _bundle = Bundle.common
  override def toString = "AUTOPILOT_VERSION" + " capabilities=" + capabilities + " version=" + version + " customVersion=" + customVersion
}

/**
 * Message implementing parts of the V2 payload specs in V1 frames for transitional support.
 * @param targetNetwork Network ID (0 for broadcast)
 * @param targetSystem System ID (0 for broadcast)
 * @param targetComponent Component ID (0 for broadcast)
 * @param messageType A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
 * @param payload Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
 */
case class V2Extension(targetNetwork: Byte = 0, targetSystem: SystemId = 0, targetComponent: ComponentId = 0, messageType: Short = 0, payload: Vector[Byte] = Vector.fill(249)(0))
extends Message with TargetComponent[V2Extension] {
  require(payload.length <= 249)
  val _id = 248
  val _name = "V2_EXTENSION"
  val _bundle = Bundle.common
  def setTargetSystem(systemId: SystemId): V2Extension = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): V2Extension = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): V2Extension = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "V2_EXTENSION" + " targetNetwork=" + targetNetwork + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " messageType=" + messageType + " payload=" + payload
}

/**
 * Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
 * @param address Starting address of the debug variables
 * @param ver Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
 * @param `type` Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
 * @param value Memory contents at specified address
 */
case class MemoryVect(address: Short = 0, ver: Byte = 0, `type`: Byte = 0, value: Vector[Byte] = Vector.fill(32)(0))
extends Message {
  require(value.length <= 32)
  val _id = 249
  val _name = "MEMORY_VECT"
  val _bundle = Bundle.common
  override def toString = "MEMORY_VECT" + " address=" + address + " ver=" + ver + " type=" + `type` + " value=" + value
}

/**
 * @param name Name
 * @param timeUsec Timestamp
 * @param x x
 * @param y y
 * @param z z
 */
case class DebugVect(name: String = "", timeUsec: Long = 0, x: Float = 0, y: Float = 0, z: Float = 0)
extends Message {
  require(name.length <= 10)
  val _id = 250
  val _name = "DEBUG_VECT"
  val _bundle = Bundle.common
  override def toString = "DEBUG_VECT" + " name=" + name + " timeUsec=" + timeUsec + " x=" + x + " y=" + y + " z=" + z
}

/**
 * Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param name Name of the debug variable
 * @param value Floating point value
 */
case class NamedValueFloat(timeBootMs: Int = 0, name: String = "", value: Float = 0)
extends Message {
  require(name.length <= 10)
  val _id = 251
  val _name = "NAMED_VALUE_FLOAT"
  val _bundle = Bundle.common
  override def toString = "NAMED_VALUE_FLOAT" + " timeBootMs=" + timeBootMs + " name=" + name + " value=" + value
}

/**
 * Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param name Name of the debug variable
 * @param value Signed integer value
 */
case class NamedValueInt(timeBootMs: Int = 0, name: String = "", value: Int = 0)
extends Message {
  require(name.length <= 10)
  val _id = 252
  val _name = "NAMED_VALUE_INT"
  val _bundle = Bundle.common
  override def toString = "NAMED_VALUE_INT" + " timeBootMs=" + timeBootMs + " name=" + name + " value=" + value
}

/**
 * Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz).
 * @param severity Severity of status. Relies on the definitions within RFC-5424. See enum MAV_SEVERITY.
 * @param text Status text message, without null termination character
 */
case class Statustext(severity: MavSeverity.Value = MavSeverity(0), text: String = "")
extends Message {
  require(text.length <= 50)
  val _id = 253
  val _name = "STATUSTEXT"
  val _bundle = Bundle.common
  override def toString = "STATUSTEXT" + " severity=" + severity + " text=" + text
}

/**
 * Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N.
 * @param timeBootMs Timestamp (milliseconds since system boot)
 * @param ind index of debug variable
 * @param value DEBUG value
 */
case class Debug(timeBootMs: Int = 0, ind: Byte = 0, value: Float = 0)
extends Message {
  val _id = 254
  val _name = "DEBUG"
  val _bundle = Bundle.common
  override def toString = "DEBUG" + " timeBootMs=" + timeBootMs + " ind=" + ind + " value=" + value
}
