// Code generated by sbt-mavgen. Manual edits will be overwritten
package scavlink.message.pixhawk

import scavlink.message._
import scavlink.message.enums._

/**
 * @param camNo Camera id
 * @param camMode Camera mode: 0 = auto, 1 = manual
 * @param triggerPin Trigger pin, 0-3 for PtGrey FireFly
 * @param interval Shutter interval, in microseconds
 * @param exposure Exposure time, in microseconds
 * @param gain Camera gain
 */
case class SetCamShutter(camNo: Byte = 0, camMode: Byte = 0, triggerPin: Byte = 0, interval: Short = 0, exposure: Short = 0, gain: Float = 0)
extends Message {
  val _id = 151
  val _name = "SET_CAM_SHUTTER"
  val _bundle = Bundle.pixhawk
  override def toString = "SET_CAM_SHUTTER" + " camNo=" + camNo + " camMode=" + camMode + " triggerPin=" + triggerPin + " interval=" + interval + " exposure=" + exposure + " gain=" + gain
}

/**
 * @param timestamp Timestamp
 * @param seq IMU seq
 * @param roll Roll angle in rad
 * @param pitch Pitch angle in rad
 * @param yaw Yaw angle in rad
 * @param localZ Local frame Z coordinate (height over ground)
 * @param lat GPS X coordinate
 * @param lon GPS Y coordinate
 * @param alt Global frame altitude
 * @param groundX Ground truth X
 * @param groundY Ground truth Y
 * @param groundZ Ground truth Z
 */
case class ImageTriggered(timestamp: Long = 0, seq: Int = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, localZ: Float = 0, lat: Float = 0, lon: Float = 0, alt: Float = 0, groundX: Float = 0, groundY: Float = 0, groundZ: Float = 0)
extends Message {
  val _id = 152
  val _name = "IMAGE_TRIGGERED"
  val _bundle = Bundle.pixhawk
  override def toString = "IMAGE_TRIGGERED" + " timestamp=" + timestamp + " seq=" + seq + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " localZ=" + localZ + " lat=" + lat + " lon=" + lon + " alt=" + alt + " groundX=" + groundX + " groundY=" + groundY + " groundZ=" + groundZ
}

/**
 * @param enable 0 to disable, 1 to enable
 */
case class ImageTriggerControl(enable: Byte = 0)
extends Message {
  val _id = 153
  val _name = "IMAGE_TRIGGER_CONTROL"
  val _bundle = Bundle.pixhawk
  override def toString = "IMAGE_TRIGGER_CONTROL" + " enable=" + enable
}

/**
 * @param camId Camera id
 * @param camNo Camera # (starts with 0)
 * @param timestamp Timestamp
 * @param validUntil Until which timestamp this buffer will stay valid
 * @param imgSeq The image sequence number
 * @param imgBufIndex Position of the image in the buffer, starts with 0
 * @param width Image width
 * @param height Image height
 * @param depth Image depth
 * @param channels Image channels
 * @param key Shared memory area key
 * @param exposure Exposure time, in microseconds
 * @param gain Camera gain
 * @param roll Roll angle in rad
 * @param pitch Pitch angle in rad
 * @param yaw Yaw angle in rad
 * @param localZ Local frame Z coordinate (height over ground)
 * @param lat GPS X coordinate
 * @param lon GPS Y coordinate
 * @param alt Global frame altitude
 * @param groundXYZ Ground truth XYZ
 */
case class ImageAvailable(camId: Long = 0, camNo: Byte = 0, timestamp: Long = 0, validUntil: Long = 0, imgSeq: Int = 0, imgBufIndex: Int = 0, width: Short = 0, height: Short = 0, depth: Short = 0, channels: Byte = 0, key: Int = 0, exposure: Int = 0, gain: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, localZ: Float = 0, lat: Float = 0, lon: Float = 0, alt: Float = 0, groundXYZ: (Float,Float,Float) = (0,0,0))
extends Message {
  val _id = 154
  val _name = "IMAGE_AVAILABLE"
  val _bundle = Bundle.pixhawk
  override def toString = "IMAGE_AVAILABLE" + " camId=" + camId + " camNo=" + camNo + " timestamp=" + timestamp + " validUntil=" + validUntil + " imgSeq=" + imgSeq + " imgBufIndex=" + imgBufIndex + " width=" + width + " height=" + height + " depth=" + depth + " channels=" + channels + " key=" + key + " exposure=" + exposure + " gain=" + gain + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " localZ=" + localZ + " lat=" + lat + " lon=" + lon + " alt=" + alt + " groundXYZ=" + groundXYZ
}

/**
 * Message sent to the MAV to set a new offset from the currently controlled position
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param x x position offset
 * @param y y position offset
 * @param z z position offset
 * @param yaw yaw orientation offset in radians, 0 = NORTH
 */
case class SetPositionControlOffset(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, x: Float = 0, y: Float = 0, z: Float = 0, yaw: Float = 0)
extends Message with TargetComponent[SetPositionControlOffset] {
  val _id = 160
  val _name = "SET_POSITION_CONTROL_OFFSET"
  val _bundle = Bundle.pixhawk
  def setTargetSystem(systemId: SystemId): SetPositionControlOffset = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): SetPositionControlOffset = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): SetPositionControlOffset = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "SET_POSITION_CONTROL_OFFSET" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " x=" + x + " y=" + y + " z=" + z + " yaw=" + yaw
}

/**
 * @param id ID of waypoint, 0 for plain position
 * @param x x position
 * @param y y position
 * @param z z position
 * @param yaw yaw orientation in radians, 0 = NORTH
 */
case class PositionControlSetpoint(id: Short = 0, x: Float = 0, y: Float = 0, z: Float = 0, yaw: Float = 0)
extends Message {
  val _id = 170
  val _name = "POSITION_CONTROL_SETPOINT"
  val _bundle = Bundle.pixhawk
  override def toString = "POSITION_CONTROL_SETPOINT" + " id=" + id + " x=" + x + " y=" + y + " z=" + z + " yaw=" + yaw
}

/**
 * @param id ID
 * @param x x position
 * @param y y position
 * @param z z position
 * @param roll roll orientation
 * @param pitch pitch orientation
 * @param yaw yaw orientation
 */
case class Marker(id: Short = 0, x: Float = 0, y: Float = 0, z: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0)
extends Message {
  val _id = 171
  val _name = "MARKER"
  val _bundle = Bundle.pixhawk
  override def toString = "MARKER" + " id=" + id + " x=" + x + " y=" + y + " z=" + z + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw
}

/**
 * @param adc1 ADC1 (J405 ADC3, LPC2148 AD0.6)
 * @param adc2 ADC2 (J405 ADC5, LPC2148 AD0.2)
 * @param adc3 ADC3 (J405 ADC6, LPC2148 AD0.1)
 * @param adc4 ADC4 (J405 ADC7, LPC2148 AD1.3)
 * @param vbat Battery voltage
 * @param temp Temperature (degrees celcius)
 * @param baro Barometric pressure (hecto Pascal)
 */
case class RawAux(adc1: Short = 0, adc2: Short = 0, adc3: Short = 0, adc4: Short = 0, vbat: Short = 0, temp: Short = 0, baro: Int = 0)
extends Message {
  val _id = 172
  val _name = "RAW_AUX"
  val _bundle = Bundle.pixhawk
  override def toString = "RAW_AUX" + " adc1=" + adc1 + " adc2=" + adc2 + " adc3=" + adc3 + " adc4=" + adc4 + " vbat=" + vbat + " temp=" + temp + " baro=" + baro
}

/**
 * @param watchdogId Watchdog ID
 * @param processCount Number of processes
 */
case class WatchdogHeartbeat(watchdogId: Short = 0, processCount: Short = 0)
extends Message {
  val _id = 180
  val _name = "WATCHDOG_HEARTBEAT"
  val _bundle = Bundle.pixhawk
  override def toString = "WATCHDOG_HEARTBEAT" + " watchdogId=" + watchdogId + " processCount=" + processCount
}

/**
 * @param watchdogId Watchdog ID
 * @param processId Process ID
 * @param name Process name
 * @param arguments Process arguments
 * @param timeout Timeout (seconds)
 */
case class WatchdogProcessInfo(watchdogId: Short = 0, processId: Short = 0, name: String = "", arguments: String = "", timeout: Int = 0)
extends Message {
  require(name.length <= 100)
  require(arguments.length <= 147)
  val _id = 181
  val _name = "WATCHDOG_PROCESS_INFO"
  val _bundle = Bundle.pixhawk
  override def toString = "WATCHDOG_PROCESS_INFO" + " watchdogId=" + watchdogId + " processId=" + processId + " name=" + name + " arguments=" + arguments + " timeout=" + timeout
}

/**
 * @param watchdogId Watchdog ID
 * @param processId Process ID
 * @param state Is running / finished / suspended / crashed
 * @param muted Is muted
 * @param pid PID
 * @param crashes Number of crashes
 */
case class WatchdogProcessStatus(watchdogId: Short = 0, processId: Short = 0, state: Byte = 0, muted: Byte = 0, pid: Int = 0, crashes: Short = 0)
extends Message {
  val _id = 182
  val _name = "WATCHDOG_PROCESS_STATUS"
  val _bundle = Bundle.pixhawk
  override def toString = "WATCHDOG_PROCESS_STATUS" + " watchdogId=" + watchdogId + " processId=" + processId + " state=" + state + " muted=" + muted + " pid=" + pid + " crashes=" + crashes
}

/**
 * @param targetSystem Target system ID
 * @param watchdogId Watchdog ID
 * @param processId Process ID
 * @param commandId Command ID
 */
case class WatchdogCommand(targetSystem: SystemId = 0, watchdogId: Short = 0, processId: Short = 0, commandId: Byte = 0)
extends Message with TargetSystem[WatchdogCommand] {
  val _id = 183
  val _name = "WATCHDOG_COMMAND"
  val _bundle = Bundle.pixhawk
  def setTargetSystem(systemId: SystemId): WatchdogCommand = copy(targetSystem = systemId)
  override def toString = "WATCHDOG_COMMAND" + " targetSystem=" + targetSystem + " watchdogId=" + watchdogId + " processId=" + processId + " commandId=" + commandId
}

/**
 * @param `type` 0: Pattern, 1: Letter
 * @param confidence Confidence of detection
 * @param file Pattern file name
 * @param detected Accepted as true detection, 0 no, 1 yes
 */
case class PatternDetected(`type`: Byte = 0, confidence: Float = 0, file: String = "", detected: Byte = 0)
extends Message {
  require(file.length <= 100)
  val _id = 190
  val _name = "PATTERN_DETECTED"
  val _bundle = Bundle.pixhawk
  override def toString = "PATTERN_DETECTED" + " type=" + `type` + " confidence=" + confidence + " file=" + file + " detected=" + detected
}

/**
 * Notifies the operator about a point of interest (POI). This can be anything detected by the
                system. This generic message is intented to help interfacing to generic visualizations and to display
                the POI on a map.
 * @param `type` 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug
 * @param color 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta
 * @param coordinateSystem 0: global, 1:local
 * @param timeout 0: no timeout, >1: timeout in seconds
 * @param x X Position
 * @param y Y Position
 * @param z Z Position
 * @param name POI name
 */
case class PointOfInterest(`type`: Byte = 0, color: Byte = 0, coordinateSystem: Byte = 0, timeout: Short = 0, x: Float = 0, y: Float = 0, z: Float = 0, name: String = "")
extends Message {
  require(name.length <= 26)
  val _id = 191
  val _name = "POINT_OF_INTEREST"
  val _bundle = Bundle.pixhawk
  override def toString = "POINT_OF_INTEREST" + " type=" + `type` + " color=" + color + " coordinateSystem=" + coordinateSystem + " timeout=" + timeout + " x=" + x + " y=" + y + " z=" + z + " name=" + name
}

/**
 * Notifies the operator about the connection of two point of interests (POI). This can be anything detected by the
                system. This generic message is intented to help interfacing to generic visualizations and to display
                the POI on a map.
 * @param `type` 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug
 * @param color 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta
 * @param coordinateSystem 0: global, 1:local
 * @param timeout 0: no timeout, >1: timeout in seconds
 * @param xp1 X1 Position
 * @param yp1 Y1 Position
 * @param zp1 Z1 Position
 * @param xp2 X2 Position
 * @param yp2 Y2 Position
 * @param zp2 Z2 Position
 * @param name POI connection name
 */
case class PointOfInterestConnection(`type`: Byte = 0, color: Byte = 0, coordinateSystem: Byte = 0, timeout: Short = 0, xp1: Float = 0, yp1: Float = 0, zp1: Float = 0, xp2: Float = 0, yp2: Float = 0, zp2: Float = 0, name: String = "")
extends Message {
  require(name.length <= 26)
  val _id = 192
  val _name = "POINT_OF_INTEREST_CONNECTION"
  val _bundle = Bundle.pixhawk
  override def toString = "POINT_OF_INTEREST_CONNECTION" + " type=" + `type` + " color=" + color + " coordinateSystem=" + coordinateSystem + " timeout=" + timeout + " xp1=" + xp1 + " yp1=" + yp1 + " zp1=" + zp1 + " xp2=" + xp2 + " yp2=" + yp2 + " zp2=" + zp2 + " name=" + name
}

/**
 * @param x x position in m
 * @param y y position in m
 * @param z z position in m
 * @param orientationAssignment Orientation assignment 0: false, 1:true
 * @param size Size in pixels
 * @param orientation Orientation
 * @param descriptor Descriptor
 * @param response Harris operator response at this location
 */
case class BriefFeature(x: Float = 0, y: Float = 0, z: Float = 0, orientationAssignment: Byte = 0, size: Short = 0, orientation: Short = 0, descriptor: Vector[Byte] = Vector.fill(32)(0), response: Float = 0)
extends Message {
  require(descriptor.length <= 32)
  val _id = 195
  val _name = "BRIEF_FEATURE"
  val _bundle = Bundle.pixhawk
  override def toString = "BRIEF_FEATURE" + " x=" + x + " y=" + y + " z=" + z + " orientationAssignment=" + orientationAssignment + " size=" + size + " orientation=" + orientation + " descriptor=" + descriptor + " response=" + response
}

/**
 * @param targetSystem The system to be controlled
 * @param roll roll
 * @param pitch pitch
 * @param yaw yaw
 * @param thrust thrust
 * @param rollManual roll control enabled auto:0, manual:1
 * @param pitchManual pitch auto:0, manual:1
 * @param yawManual yaw auto:0, manual:1
 * @param thrustManual thrust auto:0, manual:1
 */
case class AttitudeControl(targetSystem: SystemId = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, thrust: Float = 0, rollManual: Byte = 0, pitchManual: Byte = 0, yawManual: Byte = 0, thrustManual: Byte = 0)
extends Message with TargetSystem[AttitudeControl] {
  val _id = 200
  val _name = "ATTITUDE_CONTROL"
  val _bundle = Bundle.pixhawk
  def setTargetSystem(systemId: SystemId): AttitudeControl = copy(targetSystem = systemId)
  override def toString = "ATTITUDE_CONTROL" + " targetSystem=" + targetSystem + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " thrust=" + thrust + " rollManual=" + rollManual + " pitchManual=" + pitchManual + " yawManual=" + yawManual + " thrustManual=" + thrustManual
}

/**
 * @param detections Number of detections
 * @param clusterIters Number of cluster iterations
 * @param bestScore Best score
 * @param bestLat Latitude of the best detection * 1E7
 * @param bestLon Longitude of the best detection * 1E7
 * @param bestAlt Altitude of the best detection * 1E3
 * @param bestDetectionId Best detection ID
 * @param bestClusterId Best cluster ID
 * @param bestClusterIterId Best cluster ID
 * @param imagesDone Number of images already processed
 * @param imagesTodo Number of images still to process
 * @param fps Average images per seconds processed
 */
case class DetectionStats(detections: Int = 0, clusterIters: Int = 0, bestScore: Float = 0, bestLat: Int = 0, bestLon: Int = 0, bestAlt: Int = 0, bestDetectionId: Int = 0, bestClusterId: Int = 0, bestClusterIterId: Int = 0, imagesDone: Int = 0, imagesTodo: Int = 0, fps: Float = 0)
extends Message {
  val _id = 205
  val _name = "DETECTION_STATS"
  val _bundle = Bundle.pixhawk
  override def toString = "DETECTION_STATS" + " detections=" + detections + " clusterIters=" + clusterIters + " bestScore=" + bestScore + " bestLat=" + bestLat + " bestLon=" + bestLon + " bestAlt=" + bestAlt + " bestDetectionId=" + bestDetectionId + " bestClusterId=" + bestClusterId + " bestClusterIterId=" + bestClusterIterId + " imagesDone=" + imagesDone + " imagesTodo=" + imagesTodo + " fps=" + fps
}

/**
 * @param uptime Uptime of system
 * @param cpuFreq CPU frequency
 * @param cpuLoad CPU load in percent
 * @param ramUsage RAM usage in percent
 * @param ramTotal RAM size in GiB
 * @param swapUsage Swap usage in percent
 * @param swapTotal Swap size in GiB
 * @param diskHealth Disk health (-1: N/A, 0: ERR, 1: RO, 2: RW)
 * @param diskUsage Disk usage in percent
 * @param diskTotal Disk total in GiB
 * @param temp Temperature
 * @param voltage Supply voltage V
 * @param networkLoadIn Network load inbound KiB/s
 * @param networkLoadOut Network load outbound in KiB/s
 */
case class OnboardHealth(uptime: Int = 0, cpuFreq: Short = 0, cpuLoad: Byte = 0, ramUsage: Byte = 0, ramTotal: Float = 0, swapUsage: Byte = 0, swapTotal: Float = 0, diskHealth: Byte = 0, diskUsage: Byte = 0, diskTotal: Float = 0, temp: Float = 0, voltage: Float = 0, networkLoadIn: Float = 0, networkLoadOut: Float = 0)
extends Message {
  val _id = 206
  val _name = "ONBOARD_HEALTH"
  val _bundle = Bundle.pixhawk
  override def toString = "ONBOARD_HEALTH" + " uptime=" + uptime + " cpuFreq=" + cpuFreq + " cpuLoad=" + cpuLoad + " ramUsage=" + ramUsage + " ramTotal=" + ramTotal + " swapUsage=" + swapUsage + " swapTotal=" + swapTotal + " diskHealth=" + diskHealth + " diskUsage=" + diskUsage + " diskTotal=" + diskTotal + " temp=" + temp + " voltage=" + voltage + " networkLoadIn=" + networkLoadIn + " networkLoadOut=" + networkLoadOut
}
