// Code generated by sbt-mavgen. Manual edits will be overwritten
package scavlink.message.ardupilotmega

import scavlink.message._
import scavlink.message.enums._

/**
 * Offsets and calibrations values for hardware
        sensors. This makes it easier to debug the calibration process.
 * @param magOfsX magnetometer X offset
 * @param magOfsY magnetometer Y offset
 * @param magOfsZ magnetometer Z offset
 * @param magDeclination magnetic declination (radians)
 * @param rawPress raw pressure from barometer
 * @param rawTemp raw temperature from barometer
 * @param gyroCalX gyro X calibration
 * @param gyroCalY gyro Y calibration
 * @param gyroCalZ gyro Z calibration
 * @param accelCalX accel X calibration
 * @param accelCalY accel Y calibration
 * @param accelCalZ accel Z calibration
 */
case class SensorOffsets(magOfsX: Short = 0, magOfsY: Short = 0, magOfsZ: Short = 0, magDeclination: Float = 0, rawPress: Int = 0, rawTemp: Int = 0, gyroCalX: Float = 0, gyroCalY: Float = 0, gyroCalZ: Float = 0, accelCalX: Float = 0, accelCalY: Float = 0, accelCalZ: Float = 0)
extends Message {
  val _id = 150
  val _name = "SENSOR_OFFSETS"
  val _bundle = Bundle.ardupilotmega
  override def toString = "SENSOR_OFFSETS" + " magOfsX=" + magOfsX + " magOfsY=" + magOfsY + " magOfsZ=" + magOfsZ + " magDeclination=" + magDeclination + " rawPress=" + rawPress + " rawTemp=" + rawTemp + " gyroCalX=" + gyroCalX + " gyroCalY=" + gyroCalY + " gyroCalZ=" + gyroCalZ + " accelCalX=" + accelCalX + " accelCalY=" + accelCalY + " accelCalZ=" + accelCalZ
}

/**
 * Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param magOfsX magnetometer X offset
 * @param magOfsY magnetometer Y offset
 * @param magOfsZ magnetometer Z offset
 */
case class SetMagOffsets(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, magOfsX: Short = 0, magOfsY: Short = 0, magOfsZ: Short = 0)
extends Message with TargetComponent[SetMagOffsets] {
  val _id = 151
  val _name = "SET_MAG_OFFSETS"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): SetMagOffsets = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): SetMagOffsets = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): SetMagOffsets = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "SET_MAG_OFFSETS" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " magOfsX=" + magOfsX + " magOfsY=" + magOfsY + " magOfsZ=" + magOfsZ
}

/**
 * state of APM memory
 * @param brkval heap top
 * @param freemem free memory
 */
case class Meminfo(brkval: Short = 0, freemem: Short = 0)
extends Message {
  val _id = 152
  val _name = "MEMINFO"
  val _bundle = Bundle.ardupilotmega
  override def toString = "MEMINFO" + " brkval=" + brkval + " freemem=" + freemem
}

/**
 * raw ADC output
 * @param adc1 ADC output 1
 * @param adc2 ADC output 2
 * @param adc3 ADC output 3
 * @param adc4 ADC output 4
 * @param adc5 ADC output 5
 * @param adc6 ADC output 6
 */
case class ApAdc(adc1: Short = 0, adc2: Short = 0, adc3: Short = 0, adc4: Short = 0, adc5: Short = 0, adc6: Short = 0)
extends Message {
  val _id = 153
  val _name = "AP_ADC"
  val _bundle = Bundle.ardupilotmega
  override def toString = "AP_ADC" + " adc1=" + adc1 + " adc2=" + adc2 + " adc3=" + adc3 + " adc4=" + adc4 + " adc5=" + adc5 + " adc6=" + adc6
}

/**
 * Configure on-board Camera Control System.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param mode Mode enumeration from 1 to N //P, TV, AV, M, Etc (0 means ignore)
 * @param shutterSpeed Divisor number //e.g. 1000 means 1/1000 (0 means ignore)
 * @param aperture F stop number x 10 //e.g. 28 means 2.8 (0 means ignore)
 * @param iso ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore)
 * @param exposureType Exposure type enumeration from 1 to N (0 means ignore)
 * @param commandId Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once
 * @param engineCutOff Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off)
 * @param extraParam Extra parameters enumeration (0 means ignore)
 * @param extraValue Correspondent value to given extra_param
 */
case class DigicamConfigure(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, mode: Byte = 0, shutterSpeed: Short = 0, aperture: Byte = 0, iso: Byte = 0, exposureType: Byte = 0, commandId: Byte = 0, engineCutOff: Byte = 0, extraParam: Byte = 0, extraValue: Float = 0)
extends Message with TargetComponent[DigicamConfigure] {
  val _id = 154
  val _name = "DIGICAM_CONFIGURE"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): DigicamConfigure = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): DigicamConfigure = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): DigicamConfigure = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "DIGICAM_CONFIGURE" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " mode=" + mode + " shutterSpeed=" + shutterSpeed + " aperture=" + aperture + " iso=" + iso + " exposureType=" + exposureType + " commandId=" + commandId + " engineCutOff=" + engineCutOff + " extraParam=" + extraParam + " extraValue=" + extraValue
}

/**
 * Control on-board Camera Control System to take shots.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param session 0: stop, 1: start or keep it up //Session control e.g. show/hide lens
 * @param zoomPos 1 to N //Zoom's absolute position (0 means ignore)
 * @param zoomStep -100 to 100 //Zooming step value to offset zoom from the current position
 * @param focusLock 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus
 * @param shot 0: ignore, 1: shot or start filming
 * @param commandId Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once
 * @param extraParam Extra parameters enumeration (0 means ignore)
 * @param extraValue Correspondent value to given extra_param
 */
case class DigicamControl(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, session: Byte = 0, zoomPos: Byte = 0, zoomStep: Byte = 0, focusLock: Byte = 0, shot: Byte = 0, commandId: Byte = 0, extraParam: Byte = 0, extraValue: Float = 0)
extends Message with TargetComponent[DigicamControl] {
  val _id = 155
  val _name = "DIGICAM_CONTROL"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): DigicamControl = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): DigicamControl = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): DigicamControl = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "DIGICAM_CONTROL" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " session=" + session + " zoomPos=" + zoomPos + " zoomStep=" + zoomStep + " focusLock=" + focusLock + " shot=" + shot + " commandId=" + commandId + " extraParam=" + extraParam + " extraValue=" + extraValue
}

/**
 * Message to configure a camera mount, directional antenna, etc.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param mountMode mount operating mode (see MAV_MOUNT_MODE enum)
 * @param stabRoll (1 = yes, 0 = no)
 * @param stabPitch (1 = yes, 0 = no)
 * @param stabYaw (1 = yes, 0 = no)
 */
case class MountConfigure(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, mountMode: MavMountMode.Value = MavMountMode(0), stabRoll: Byte = 0, stabPitch: Byte = 0, stabYaw: Byte = 0)
extends Message with TargetComponent[MountConfigure] {
  val _id = 156
  val _name = "MOUNT_CONFIGURE"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): MountConfigure = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MountConfigure = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MountConfigure = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MOUNT_CONFIGURE" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " mountMode=" + mountMode + " stabRoll=" + stabRoll + " stabPitch=" + stabPitch + " stabYaw=" + stabYaw
}

/**
 * Message to control a camera mount, directional antenna, etc.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param inputA pitch(deg*100) or lat, depending on mount mode
 * @param inputB roll(deg*100) or lon depending on mount mode
 * @param inputC yaw(deg*100) or alt (in cm) depending on mount mode
 * @param savePosition if "1" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING)
 */
case class MountControl(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, inputA: Int = 0, inputB: Int = 0, inputC: Int = 0, savePosition: Byte = 0)
extends Message with TargetComponent[MountControl] {
  val _id = 157
  val _name = "MOUNT_CONTROL"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): MountControl = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MountControl = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MountControl = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MOUNT_CONTROL" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " inputA=" + inputA + " inputB=" + inputB + " inputC=" + inputC + " savePosition=" + savePosition
}

/**
 * Message with some status from APM to GCS about camera or antenna mount
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param pointingA pitch(deg*100)
 * @param pointingB roll(deg*100)
 * @param pointingC yaw(deg*100)
 */
case class MountStatus(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, pointingA: Int = 0, pointingB: Int = 0, pointingC: Int = 0)
extends Message with TargetComponent[MountStatus] {
  val _id = 158
  val _name = "MOUNT_STATUS"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): MountStatus = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): MountStatus = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): MountStatus = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "MOUNT_STATUS" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " pointingA=" + pointingA + " pointingB=" + pointingB + " pointingC=" + pointingC
}

/**
 * A fence point. Used to set a point when from
	      GCS -> MAV. Also used to return a point from MAV -> GCS
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param idx point index (first point is 1, 0 is for return point)
 * @param count total number of points (for sanity checking)
 * @param lat Latitude of point
 * @param lng Longitude of point
 */
case class FencePoint(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, idx: Byte = 0, count: Byte = 0, lat: Float = 0, lng: Float = 0)
extends Message with TargetComponent[FencePoint] {
  val _id = 160
  val _name = "FENCE_POINT"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): FencePoint = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FencePoint = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FencePoint = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FENCE_POINT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " idx=" + idx + " count=" + count + " lat=" + lat + " lng=" + lng
}

/**
 * Request a current fence point from MAV
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param idx point index (first point is 1, 0 is for return point)
 */
case class FenceFetchPoint(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, idx: Byte = 0)
extends Message with TargetComponent[FenceFetchPoint] {
  val _id = 161
  val _name = "FENCE_FETCH_POINT"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): FenceFetchPoint = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): FenceFetchPoint = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): FenceFetchPoint = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "FENCE_FETCH_POINT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " idx=" + idx
}

/**
 * Status of geo-fencing. Sent in extended
	    status stream when fencing enabled
 * @param breachStatus 0 if currently inside fence, 1 if outside
 * @param breachCount number of fence breaches
 * @param breachType last breach type (see FENCE_BREACH_* enum)
 * @param breachTime time of last breach in milliseconds since boot
 */
case class FenceStatus(breachStatus: Byte = 0, breachCount: Short = 0, breachType: FenceBreach.Value = FenceBreach(0), breachTime: Int = 0)
extends Message {
  val _id = 162
  val _name = "FENCE_STATUS"
  val _bundle = Bundle.ardupilotmega
  override def toString = "FENCE_STATUS" + " breachStatus=" + breachStatus + " breachCount=" + breachCount + " breachType=" + breachType + " breachTime=" + breachTime
}

/**
 * Status of DCM attitude estimator
 * @param omegaIx X gyro drift estimate rad/s
 * @param omegaIy Y gyro drift estimate rad/s
 * @param omegaIz Z gyro drift estimate rad/s
 * @param accelWeight average accel_weight
 * @param renormVal average renormalisation value
 * @param errorRp average error_roll_pitch value
 * @param errorYaw average error_yaw value
 */
case class Ahrs(omegaIx: Float = 0, omegaIy: Float = 0, omegaIz: Float = 0, accelWeight: Float = 0, renormVal: Float = 0, errorRp: Float = 0, errorYaw: Float = 0)
extends Message {
  val _id = 163
  val _name = "AHRS"
  val _bundle = Bundle.ardupilotmega
  override def toString = "AHRS" + " omegaIx=" + omegaIx + " omegaIy=" + omegaIy + " omegaIz=" + omegaIz + " accelWeight=" + accelWeight + " renormVal=" + renormVal + " errorRp=" + errorRp + " errorYaw=" + errorYaw
}

/**
 * Status of simulation environment, if used
 * @param roll Roll angle (rad)
 * @param pitch Pitch angle (rad)
 * @param yaw Yaw angle (rad)
 * @param xacc X acceleration m/s/s
 * @param yacc Y acceleration m/s/s
 * @param zacc Z acceleration m/s/s
 * @param xgyro Angular speed around X axis rad/s
 * @param ygyro Angular speed around Y axis rad/s
 * @param zgyro Angular speed around Z axis rad/s
 * @param lat Latitude in degrees * 1E7
 * @param lng Longitude in degrees * 1E7
 */
case class Simstate(roll: Float = 0, pitch: Float = 0, yaw: Float = 0, xacc: Float = 0, yacc: Float = 0, zacc: Float = 0, xgyro: Float = 0, ygyro: Float = 0, zgyro: Float = 0, lat: Int = 0, lng: Int = 0)
extends Message {
  val _id = 164
  val _name = "SIMSTATE"
  val _bundle = Bundle.ardupilotmega
  override def toString = "SIMSTATE" + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " xacc=" + xacc + " yacc=" + yacc + " zacc=" + zacc + " xgyro=" + xgyro + " ygyro=" + ygyro + " zgyro=" + zgyro + " lat=" + lat + " lng=" + lng
}

/**
 * Status of key hardware
 * @param vcc board voltage (mV)
 * @param i2cerr I2C error count
 */
case class Hwstatus(vcc: Short = 0, i2cerr: Byte = 0)
extends Message {
  val _id = 165
  val _name = "HWSTATUS"
  val _bundle = Bundle.ardupilotmega
  override def toString = "HWSTATUS" + " vcc=" + vcc + " i2cerr=" + i2cerr
}

/**
 * Status generated by radio
 * @param rssi local signal strength
 * @param remrssi remote signal strength
 * @param txbuf how full the tx buffer is as a percentage
 * @param noise background noise level
 * @param remnoise remote background noise level
 * @param rxerrors receive errors
 * @param fixed count of error corrected packets
 */
case class Radio(rssi: Byte = 0, remrssi: Byte = 0, txbuf: Byte = 0, noise: Byte = 0, remnoise: Byte = 0, rxerrors: Short = 0, fixed: Short = 0)
extends Message {
  val _id = 166
  val _name = "RADIO"
  val _bundle = Bundle.ardupilotmega
  override def toString = "RADIO" + " rssi=" + rssi + " remrssi=" + remrssi + " txbuf=" + txbuf + " noise=" + noise + " remnoise=" + remnoise + " rxerrors=" + rxerrors + " fixed=" + fixed
}

/**
 * Status of AP_Limits. Sent in extended
	    status stream when AP_Limits is enabled
 * @param limitsState state of AP_Limits, (see enum LimitState, LIMITS_STATE)
 * @param lastTrigger time of last breach in milliseconds since boot
 * @param lastAction time of last recovery action in milliseconds since boot
 * @param lastRecovery time of last successful recovery in milliseconds since boot
 * @param lastClear time of last all-clear in milliseconds since boot
 * @param breachCount number of fence breaches
 * @param modsEnabled AP_Limit_Module bitfield of enabled modules, (see enum moduleid or LIMIT_MODULE)
 * @param modsRequired AP_Limit_Module bitfield of required modules, (see enum moduleid or LIMIT_MODULE)
 * @param modsTriggered AP_Limit_Module bitfield of triggered modules, (see enum moduleid or LIMIT_MODULE)
 */
case class LimitsStatus(limitsState: LimitsState.Value = LimitsState(0), lastTrigger: Int = 0, lastAction: Int = 0, lastRecovery: Int = 0, lastClear: Int = 0, breachCount: Short = 0, modsEnabled: Byte = 0, modsRequired: Byte = 0, modsTriggered: Byte = 0)
extends Message {
  val _id = 167
  val _name = "LIMITS_STATUS"
  val _bundle = Bundle.ardupilotmega
  override def toString = "LIMITS_STATUS" + " limitsState=" + limitsState + " lastTrigger=" + lastTrigger + " lastAction=" + lastAction + " lastRecovery=" + lastRecovery + " lastClear=" + lastClear + " breachCount=" + breachCount + " modsEnabled=" + modsEnabled + " modsRequired=" + modsRequired + " modsTriggered=" + modsTriggered
}

/**
 * Wind estimation
 * @param direction wind direction that wind is coming from (degrees)
 * @param speed wind speed in ground plane (m/s)
 * @param speedZ vertical wind speed (m/s)
 */
case class Wind(direction: Float = 0, speed: Float = 0, speedZ: Float = 0)
extends Message {
  val _id = 168
  val _name = "WIND"
  val _bundle = Bundle.ardupilotmega
  override def toString = "WIND" + " direction=" + direction + " speed=" + speed + " speedZ=" + speedZ
}

/**
 * Data packet, size 16
 * @param `type` data type
 * @param len data length
 * @param data raw data
 */
case class Data16(`type`: Byte = 0, len: Byte = 0, data: Vector[Byte] = Vector.fill(16)(0))
extends Message {
  require(data.length <= 16)
  val _id = 169
  val _name = "DATA16"
  val _bundle = Bundle.ardupilotmega
  override def toString = "DATA16" + " type=" + `type` + " len=" + len + " data=" + data
}

/**
 * Data packet, size 32
 * @param `type` data type
 * @param len data length
 * @param data raw data
 */
case class Data32(`type`: Byte = 0, len: Byte = 0, data: Vector[Byte] = Vector.fill(32)(0))
extends Message {
  require(data.length <= 32)
  val _id = 170
  val _name = "DATA32"
  val _bundle = Bundle.ardupilotmega
  override def toString = "DATA32" + " type=" + `type` + " len=" + len + " data=" + data
}

/**
 * Data packet, size 64
 * @param `type` data type
 * @param len data length
 * @param data raw data
 */
case class Data64(`type`: Byte = 0, len: Byte = 0, data: Vector[Byte] = Vector.fill(64)(0))
extends Message {
  require(data.length <= 64)
  val _id = 171
  val _name = "DATA64"
  val _bundle = Bundle.ardupilotmega
  override def toString = "DATA64" + " type=" + `type` + " len=" + len + " data=" + data
}

/**
 * Data packet, size 96
 * @param `type` data type
 * @param len data length
 * @param data raw data
 */
case class Data96(`type`: Byte = 0, len: Byte = 0, data: Vector[Byte] = Vector.fill(96)(0))
extends Message {
  require(data.length <= 96)
  val _id = 172
  val _name = "DATA96"
  val _bundle = Bundle.ardupilotmega
  override def toString = "DATA96" + " type=" + `type` + " len=" + len + " data=" + data
}

/**
 * Rangefinder reporting
 * @param distance distance in meters
 * @param voltage raw voltage if available, zero otherwise
 */
case class Rangefinder(distance: Float = 0, voltage: Float = 0)
extends Message {
  val _id = 173
  val _name = "RANGEFINDER"
  val _bundle = Bundle.ardupilotmega
  override def toString = "RANGEFINDER" + " distance=" + distance + " voltage=" + voltage
}

/**
 * Airspeed auto-calibration
 * @param vx GPS velocity north m/s
 * @param vy GPS velocity east m/s
 * @param vz GPS velocity down m/s
 * @param diffPressure Differential pressure pascals
 * @param eas2tas Estimated to true airspeed ratio
 * @param ratio Airspeed ratio
 * @param stateX EKF state x
 * @param stateY EKF state y
 * @param stateZ EKF state z
 * @param pax EKF Pax
 * @param pby EKF Pby
 * @param pcz EKF Pcz
 */
case class AirspeedAutocal(vx: Float = 0, vy: Float = 0, vz: Float = 0, diffPressure: Float = 0, eas2tas: Float = 0, ratio: Float = 0, stateX: Float = 0, stateY: Float = 0, stateZ: Float = 0, pax: Float = 0, pby: Float = 0, pcz: Float = 0)
extends Message {
  val _id = 174
  val _name = "AIRSPEED_AUTOCAL"
  val _bundle = Bundle.ardupilotmega
  override def toString = "AIRSPEED_AUTOCAL" + " vx=" + vx + " vy=" + vy + " vz=" + vz + " diffPressure=" + diffPressure + " eas2tas=" + eas2tas + " ratio=" + ratio + " stateX=" + stateX + " stateY=" + stateY + " stateZ=" + stateZ + " pax=" + pax + " pby=" + pby + " pcz=" + pcz
}

/**
 * A rally point. Used to set a point when from GCS -> MAV. Also used to return a point from MAV -> GCS
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param idx point index (first point is 0)
 * @param count total number of points (for sanity checking)
 * @param lat Latitude of point in degrees * 1E7
 * @param lng Longitude of point in degrees * 1E7
 * @param alt Transit / loiter altitude in meters relative to home
 * @param breakAlt Break altitude in meters relative to home
 * @param landDir Heading to aim for when landing. In centi-degrees.
 * @param flags See RALLY_FLAGS enum for definition of the bitmask.
 */
case class RallyPoint(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, idx: Byte = 0, count: Byte = 0, lat: Int = 0, lng: Int = 0, alt: Short = 0, breakAlt: Short = 0, landDir: Short = 0, flags: Byte = 0)
extends Message with TargetComponent[RallyPoint] {
  val _id = 175
  val _name = "RALLY_POINT"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): RallyPoint = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): RallyPoint = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): RallyPoint = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "RALLY_POINT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " idx=" + idx + " count=" + count + " lat=" + lat + " lng=" + lng + " alt=" + alt + " breakAlt=" + breakAlt + " landDir=" + landDir + " flags=" + flags
}

/**
 * Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not respond if the request is invalid.
 * @param targetSystem System ID
 * @param targetComponent Component ID
 * @param idx point index (first point is 0)
 */
case class RallyFetchPoint(targetSystem: SystemId = 0, targetComponent: ComponentId = 0, idx: Byte = 0)
extends Message with TargetComponent[RallyFetchPoint] {
  val _id = 176
  val _name = "RALLY_FETCH_POINT"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): RallyFetchPoint = copy(targetSystem = systemId)
  def setTargetComponent(componentId: ComponentId): RallyFetchPoint = copy(targetComponent = componentId)
  def setTarget(systemId: SystemId, componentId: ComponentId): RallyFetchPoint = copy(targetSystem = systemId, targetComponent = componentId)
  override def toString = "RALLY_FETCH_POINT" + " targetSystem=" + targetSystem + " targetComponent=" + targetComponent + " idx=" + idx
}

/**
 * Status of compassmot calibration
 * @param throttle throttle (percent*10)
 * @param current current (amps)
 * @param interference interference (percent)
 * @param compensationx Motor Compensation X
 * @param compensationy Motor Compensation Y
 * @param compensationz Motor Compensation Z
 */
case class CompassmotStatus(throttle: Short = 0, current: Float = 0, interference: Short = 0, compensationx: Float = 0, compensationy: Float = 0, compensationz: Float = 0)
extends Message {
  val _id = 177
  val _name = "COMPASSMOT_STATUS"
  val _bundle = Bundle.ardupilotmega
  override def toString = "COMPASSMOT_STATUS" + " throttle=" + throttle + " current=" + current + " interference=" + interference + " compensationx=" + compensationx + " compensationy=" + compensationy + " compensationz=" + compensationz
}

/**
 * Status of secondary AHRS filter if available
 * @param roll Roll angle (rad)
 * @param pitch Pitch angle (rad)
 * @param yaw Yaw angle (rad)
 * @param altitude Altitude (MSL)
 * @param lat Latitude in degrees * 1E7
 * @param lng Longitude in degrees * 1E7
 */
case class Ahrs2(roll: Float = 0, pitch: Float = 0, yaw: Float = 0, altitude: Float = 0, lat: Int = 0, lng: Int = 0)
extends Message {
  val _id = 178
  val _name = "AHRS2"
  val _bundle = Bundle.ardupilotmega
  override def toString = "AHRS2" + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " altitude=" + altitude + " lat=" + lat + " lng=" + lng
}

/**
 * Camera Event
 * @param timeUsec Image timestamp (microseconds since UNIX epoch, according to camera clock)
 * @param targetSystem System ID
 * @param camIdx Camera ID
 * @param imgIdx Image index
 * @param eventId See CAMERA_STATUS_TYPES enum for definition of the bitmask
 * @param p1 Parameter 1 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
 * @param p2 Parameter 2 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
 * @param p3 Parameter 3 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
 * @param p4 Parameter 4 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
 */
case class CameraStatus(timeUsec: Long = 0, targetSystem: SystemId = 0, camIdx: Byte = 0, imgIdx: Short = 0, eventId: Byte = 0, p1: Float = 0, p2: Float = 0, p3: Float = 0, p4: Float = 0)
extends Message with TargetSystem[CameraStatus] {
  val _id = 179
  val _name = "CAMERA_STATUS"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): CameraStatus = copy(targetSystem = systemId)
  override def toString = "CAMERA_STATUS" + " timeUsec=" + timeUsec + " targetSystem=" + targetSystem + " camIdx=" + camIdx + " imgIdx=" + imgIdx + " eventId=" + eventId + " p1=" + p1 + " p2=" + p2 + " p3=" + p3 + " p4=" + p4
}

/**
 * Camera Capture Feedback
 * @param timeUsec Image timestamp (microseconds since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB)
 * @param targetSystem System ID
 * @param camIdx Camera ID
 * @param imgIdx Image index
 * @param lat Latitude in (deg * 1E7)
 * @param lng Longitude in (deg * 1E7)
 * @param altMsl Altitude Absolute (meters AMSL)
 * @param altRel Altitude Relative (meters above HOME location)
 * @param roll Camera Roll angle (earth frame, degrees, +-180)
 * @param pitch Camera Pitch angle (earth frame, degrees, +-180)
 * @param yaw Camera Yaw (earth frame, degrees, 0-360, true)
 * @param focLen Focal Length (mm)
 * @param flags See CAMERA_FEEDBACK_FLAGS enum for definition of the bitmask
 */
case class CameraFeedback(timeUsec: Long = 0, targetSystem: SystemId = 0, camIdx: Byte = 0, imgIdx: Short = 0, lat: Int = 0, lng: Int = 0, altMsl: Float = 0, altRel: Float = 0, roll: Float = 0, pitch: Float = 0, yaw: Float = 0, focLen: Float = 0, flags: Byte = 0)
extends Message with TargetSystem[CameraFeedback] {
  val _id = 180
  val _name = "CAMERA_FEEDBACK"
  val _bundle = Bundle.ardupilotmega
  def setTargetSystem(systemId: SystemId): CameraFeedback = copy(targetSystem = systemId)
  override def toString = "CAMERA_FEEDBACK" + " timeUsec=" + timeUsec + " targetSystem=" + targetSystem + " camIdx=" + camIdx + " imgIdx=" + imgIdx + " lat=" + lat + " lng=" + lng + " altMsl=" + altMsl + " altRel=" + altRel + " roll=" + roll + " pitch=" + pitch + " yaw=" + yaw + " focLen=" + focLen + " flags=" + flags
}

/**
 * 2nd Battery status
 * @param voltage voltage in millivolts
 * @param currentBattery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
 */
case class Battery2(voltage: Short = 0, currentBattery: Short = 0)
extends Message {
  val _id = 181
  val _name = "BATTERY2"
  val _bundle = Bundle.ardupilotmega
  override def toString = "BATTERY2" + " voltage=" + voltage + " currentBattery=" + currentBattery
}
